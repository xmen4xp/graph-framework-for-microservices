// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	customerrors "errors"
	"fmt"
	"os"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	fakeDynamicClientset "k8s.io/client-go/dynamic/fake"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

	baseClientset "nexustempmodule/client/clientset/versioned"
	fakeBaseClienset "nexustempmodule/client/clientset/versioned/fake"
	"nexustempmodule/common"
	"nexustempmodule/helper"

	baseconfigtsmtanzuvmwarecomv1 "nexustempmodule/apis/config.tsm.tanzu.vmware.com/v1"
	basegnstsmtanzuvmwarecomv1 "nexustempmodule/apis/gns.tsm.tanzu.vmware.com/v1"
	basepolicypkgtsmtanzuvmwarecomv1 "nexustempmodule/apis/policypkg.tsm.tanzu.vmware.com/v1"
	baseroottsmtanzuvmwarecomv1 "nexustempmodule/apis/root.tsm.tanzu.vmware.com/v1"
	baseservicegrouptsmtanzuvmwarecomv1 "nexustempmodule/apis/servicegroup.tsm.tanzu.vmware.com/v1"

	informerconfigtsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/config.tsm.tanzu.vmware.com/v1"
	informergnstsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/gns.tsm.tanzu.vmware.com/v1"
	informerpolicypkgtsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/policypkg.tsm.tanzu.vmware.com/v1"
	informerroottsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/root.tsm.tanzu.vmware.com/v1"
	informerservicegrouptsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/servicegroup.tsm.tanzu.vmware.com/v1"
)

var log = logrus.New()

const maxRetryCount = 60
const sleepTime = 5
const maxRetryCount1SecSleep = 300

const ownershipAnnotation string = "Ownership"
const nexusDeferredDeleteAnnotation string = "nexus.com/nexus-deferred-delete"

// informerResyncPeriod is in second, default value is 10 Hrs(36000 Sec). INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
var informerResyncPeriod time.Duration = 36000

type Clientset struct {
	baseClient        baseClientset.Interface
	dynamicClient     dynamic.Interface
	rootTsmV1         *RootTsmV1
	configTsmV1       *ConfigTsmV1
	gnsTsmV1          *GnsTsmV1
	servicegroupTsmV1 *ServicegroupTsmV1
	policypkgTsmV1    *PolicypkgTsmV1
}

type subscription struct {
	informer          cache.SharedIndexInformer
	stop              chan struct{}
	WriteCacheObjects *sync.Map
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer) {
	s := subscription{
		informer:          informer,
		stop:              make(chan struct{}),
		WriteCacheObjects: &sync.Map{},
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key, s)
}

func (c *Clientset) SubscribeAll() {
	var key string

	key = "roots.root.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerroottsmtanzuvmwarecomv1.NewRootInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	key = "configs.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewConfigInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := configConfigTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "footypeabcs.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewFooTypeABCInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := footypeabcConfigTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "domains.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewDomainInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := domainConfigTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "foos.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewFooInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := fooGnsTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "gnses.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewGnsInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := gnsGnsTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "barchilds.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewBarChildInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := barchildGnsTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "ignorechilds.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewIgnoreChildInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := ignorechildGnsTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "dnses.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewDnsInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := dnsGnsTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := svcgroupServicegroupTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupLinkInfoInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := svcgrouplinkinfoServicegroupTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := accesscontrolpolicyPolicypkgTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewACPConfigInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := acpconfigPolicypkgTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewVMpolicyInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := vmpolicyPolicypkgTsmV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

}

func (c *Clientset) UnsubscribeAll() {
	subscriptionMap.Range(func(key, s interface{}) bool {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	customFormatter := new(logrus.TextFormatter)
	customFormatter.TimestampFormat = "2006-01-02 15:04:05"
	log.SetFormatter(customFormatter)
	customFormatter.FullTimestamp = true
	if os.Getenv("NEXUS_LOG_LEVEL") == "debug" {
		log.SetLevel(logrus.DebugLevel)
		log.Debug("Nexus debug log enabled")
	}

	// INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
	stringResyncPeriod := os.Getenv("INFORMER_RESYNC_PERIOD")
	if stringResyncPeriod != "" {
		intResyncPeriod, err := strconv.Atoi(stringResyncPeriod)
		if err != nil {
			log.Errorf("env INFORMER_RESYNC_PERIOD is not set with correct value")
		} else {
			informerResyncPeriod = time.Duration(intResyncPeriod)
			log.Debugf("Resync Period for informers is set to %+v second", informerResyncPeriod)
		}
	}

	client := &Clientset{}
	client.baseClient = baseClient
	client.dynamicClient, _ = dynamic.NewForConfig(config) // TBD: check and react for error
	client.rootTsmV1 = newRootTsmV1(client)
	client.configTsmV1 = newConfigTsmV1(client)
	client.gnsTsmV1 = newGnsTsmV1(client)
	client.servicegroupTsmV1 = newServicegroupTsmV1(client)
	client.policypkgTsmV1 = newPolicypkgTsmV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	scheme := runtime.NewScheme()
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.dynamicClient = fakeDynamicClientset.NewSimpleDynamicClient(scheme)
	client.rootTsmV1 = newRootTsmV1(client)
	client.configTsmV1 = newConfigTsmV1(client)
	client.gnsTsmV1 = newGnsTsmV1(client)
	client.servicegroupTsmV1 = newServicegroupTsmV1(client)
	client.policypkgTsmV1 = newPolicypkgTsmV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Root() *RootTsmV1 {
	return c.rootTsmV1
}
func (c *Clientset) Config() *ConfigTsmV1 {
	return c.configTsmV1
}
func (c *Clientset) Gns() *GnsTsmV1 {
	return c.gnsTsmV1
}
func (c *Clientset) Servicegroup() *ServicegroupTsmV1 {
	return c.servicegroupTsmV1
}
func (c *Clientset) Policypkg() *PolicypkgTsmV1 {
	return c.policypkgTsmV1
}

type RootTsmV1 struct {
	client *Clientset
}

func newRootTsmV1(client *Clientset) *RootTsmV1 {
	return &RootTsmV1{
		client: client,
	}
}

type ConfigTsmV1 struct {
	client *Clientset
}

func newConfigTsmV1(client *Clientset) *ConfigTsmV1 {
	return &ConfigTsmV1{
		client: client,
	}
}

type GnsTsmV1 struct {
	client *Clientset
}

func newGnsTsmV1(client *Clientset) *GnsTsmV1 {
	return &GnsTsmV1{
		client: client,
	}
}

type ServicegroupTsmV1 struct {
	client *Clientset
}

func newServicegroupTsmV1(client *Clientset) *ServicegroupTsmV1 {
	return &ServicegroupTsmV1{
		client: client,
	}
}

type PolicypkgTsmV1 struct {
	client *Clientset
}

func newPolicypkgTsmV1(client *Clientset) *PolicypkgTsmV1 {
	return &PolicypkgTsmV1{
		client: client,
	}
}

func (group *RootTsmV1) GetRootChildrenMap() map[string]baseroottsmtanzuvmwarecomv1.Child {
	return map[string]baseroottsmtanzuvmwarecomv1.Child{}
}

func (group *RootTsmV1) GetRootChild(grp, kind, name string) baseroottsmtanzuvmwarecomv1.Child {
	return baseroottsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) GetRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRootByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseroottsmtanzuvmwarecomv1.Root)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRootByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseroottsmtanzuvmwarecomv1.Root).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRootByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RootRoot{
					client: group.client,
					Root:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RootRoot{
				client: group.client,
				Root:   resWrCache.(*baseroottsmtanzuvmwarecomv1.Root),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootTsmV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RootRoot{
				client: group.client,
				Root:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRootByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Roots: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRootByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRootByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRootByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) ForceReadRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	log.Debugf("[ForceReadRootByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootTsmV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRootByName] Failed to Get Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Roots: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRootByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRootByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRootByName] Executed Successfully :%s", hashedName)
			return &RootRoot{
				client: group.client,
				Root:   result,
			}, nil
		}
	}
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRootByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseroottsmtanzuvmwarecomv1.Root
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootTsmV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRootByName] Failed to get Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Roots: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRootByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRootByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRootByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("roots.root.tsm.tanzu.vmware.com", hashedName, "configs.config.tsm.tanzu.vmware.com") {
		err := group.client.Config().DeleteConfigByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("roots.root.tsm.tanzu.vmware.com", hashedName, "configs.config.tsm.tanzu.vmware.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RootTsmV1().
			Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRootByName] failed to delete Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Roots: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRootByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRootByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRootByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("roots.root.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	return nil
}

// CreateRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootTsmV1) CreateRootByName(ctx context.Context,
	objToCreate *baseroottsmtanzuvmwarecomv1.Root) (*RootRoot, error) {
	log.Debugf("[CreateRootByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.ConfigGvk = nil

	var (
		retryCount int
		result     *baseroottsmtanzuvmwarecomv1.Root
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootTsmV1().
			Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRootByName] Failed to create Root: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Root: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRootByName] context canceled while creating Root: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[CreateRootByName] found unexpected error while creating Root: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRootByName] Root: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("roots.root.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateRootByName] Root: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	log.Debugf("[CreateRootByName] Executed Successfully: %s", objToCreate.GetName())
	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// UpdateRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootTsmV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baseroottsmtanzuvmwarecomv1.Root) (*RootRoot, error) {
	log.Debugf("[UpdateRootByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Root().GetRootByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["roots.root.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseroottsmtanzuvmwarecomv1.Root
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RootTsmV1().
			Roots().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRootByName] Failed to patch Root %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Root Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRootByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Root: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Root deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRootByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRootByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Root Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRootByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Root: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Root Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRootByName] Patch Root Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("roots.root.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateRootByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRootByName] Executed Successfully %s", objToUpdate.GetName())
	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// ListRoots returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootTsmV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*RootRoot, err error) {
	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootRoot, len(items))
		for k, v := range items {
			item, _ := v.(*baseroottsmtanzuvmwarecomv1.Root)
			result[k] = &RootRoot{
				client: group.client,
				Root:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootTsmV1().
			Roots().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootRoot, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootRoot{
				client: group.client,
				Root:   &item,
			}
		}
	}
	return
}

type RootRoot struct {
	client *Clientset
	*baseroottsmtanzuvmwarecomv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *RootRoot) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootRoot) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateRootByName(ctx, obj.Root)
	if err != nil {
		return err
	}
	obj.Root = result.Root
	return nil
}

// GetRootRoot calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetRootRoot(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nil, helper.DEFAULT_KEY)
	return c.Root().GetRootByName(ctx, hashedName)
}

func (c *Clientset) RootRoot() *rootRootTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.root.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &rootRootTsmV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddRootRoot calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddRootRoot(ctx context.Context,
	objToCreate *baseroottsmtanzuvmwarecomv1.Root) (result *RootRoot, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Root().CreateRootByName(ctx, objToCreate)
}

// DeleteRootRoot calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteRootRoot(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nil, helper.DEFAULT_KEY)
	return c.Root().DeleteRootByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *RootRoot) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	children := GetChildren("roots.root.tsm.tanzu.vmware.com", obj.Name, "configs.config.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.Root", "Config")
	}
	return obj.client.Config().GetConfigByName(ctx, children[0])
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddConfig(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (result *ConfigConfig, err error) {
	log.Debugf("[AddConfig] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	log.Debugf("[AddConfig] Config created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	log.Debugf("[AddConfig] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootRoot) DeleteConfig(ctx context.Context) (err error) {
	children := GetChildren("roots.root.tsm.tanzu.vmware.com", obj.Name, "configs.config.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteConfig] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Config().DeleteConfigByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootRootTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootRootTsmV1Chainer) Subscribe() {
	key := "roots.root.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerroottsmtanzuvmwarecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}
}

func (c *rootRootTsmV1Chainer) Unsubscribe() {
	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *rootRootTsmV1Chainer) IsSubscribed() bool {
	key := "roots.root.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *rootRootTsmV1Chainer) RegisterEventHandler(addCB func(obj *RootRoot), updateCB func(oldObj, newObj *RootRoot), deleteCB func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerroottsmtanzuvmwarecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baseroottsmtanzuvmwarecomv1.Root),
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootRoot{
				client: c.client,
				Root:   oldObj.(*baseroottsmtanzuvmwarecomv1.Root),
			}
			newData := &RootRoot{
				client: c.client,
				Root:   newObj.(*baseroottsmtanzuvmwarecomv1.Root),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baseroottsmtanzuvmwarecomv1.Root),
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *rootRootTsmV1Chainer) RegisterAddCallback(cbfn func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerroottsmtanzuvmwarecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baseroottsmtanzuvmwarecomv1.Root),
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *rootRootTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerroottsmtanzuvmwarecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootRoot{
				client: c.client,
				Root:   oldObj.(*baseroottsmtanzuvmwarecomv1.Root),
			}
			newData := &RootRoot{
				client: c.client,
				Root:   newObj.(*baseroottsmtanzuvmwarecomv1.Root),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *rootRootTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerroottsmtanzuvmwarecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baseroottsmtanzuvmwarecomv1.Root),
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *rootRootTsmV1Chainer) Config(name string) *configConfigTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.tsm.tanzu.vmware.com"] = name
	return &configConfigTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootRootTsmV1Chainer) GetConfig(ctx context.Context, displayName string) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootTsmV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootTsmV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

func (group *ConfigTsmV1) GetConfigChildrenMap() map[string]baseconfigtsmtanzuvmwarecomv1.Child {
	return map[string]baseconfigtsmtanzuvmwarecomv1.Child{}
}

func (group *ConfigTsmV1) GetConfigChild(grp, kind, name string) baseconfigtsmtanzuvmwarecomv1.Child {
	return baseconfigtsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetConfigByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseconfigtsmtanzuvmwarecomv1.Config)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetConfigByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseconfigtsmtanzuvmwarecomv1.Config).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetConfigByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ConfigConfig{
					client: group.client,
					Config: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ConfigConfig{
				client: group.client,
				Config: resWrCache.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetConfigByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetConfigByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadConfigByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) ForceReadConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	log.Debugf("[ForceReadConfigByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadConfigByName] Failed to Get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadConfigByName] Executed Successfully :%s", hashedName)
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		}
	}
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteConfigByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseconfigtsmtanzuvmwarecomv1.Config
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteConfigByName] Failed to get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteConfigByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("configs.config.tsm.tanzu.vmware.com", hashedName, "gnses.gns.tsm.tanzu.vmware.com") {
		err := group.client.Gns().DeleteGnsByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.tsm.tanzu.vmware.com", hashedName, "gnses.gns.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("configs.config.tsm.tanzu.vmware.com", hashedName, "dnses.gns.tsm.tanzu.vmware.com") {
		err := group.client.Gns().DeleteDnsByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.tsm.tanzu.vmware.com", hashedName, "dnses.gns.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("configs.config.tsm.tanzu.vmware.com", hashedName, "vmpolicies.policypkg.tsm.tanzu.vmware.com") {
		err := group.client.Policypkg().DeleteVMpolicyByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.tsm.tanzu.vmware.com", hashedName, "vmpolicies.policypkg.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("configs.config.tsm.tanzu.vmware.com", hashedName, "domains.config.tsm.tanzu.vmware.com") {
		err := group.client.Config().DeleteDomainByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.tsm.tanzu.vmware.com", hashedName, "domains.config.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("configs.config.tsm.tanzu.vmware.com", hashedName, "footypeabcs.config.tsm.tanzu.vmware.com") {
		err := group.client.Config().DeleteFooTypeABCByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.tsm.tanzu.vmware.com", hashedName, "footypeabcs.config.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("configs.config.tsm.tanzu.vmware.com", hashedName, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com") {
		err := group.client.Servicegroup().DeleteSvcGroupLinkInfoByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.tsm.tanzu.vmware.com", hashedName, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ConfigTsmV1().
			Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteConfigByName] failed to delete Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteConfigByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("configs.config.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteConfigByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("roots.root.tsm.tanzu.vmware.com", parentName, "configs.config.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigTsmV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (*ConfigConfig, error) {
	log.Debugf("[CreateConfigByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GNSGvk = nil
	objToCreate.Spec.DNSGvk = nil
	objToCreate.Spec.VMPPoliciesGvk = nil
	objToCreate.Spec.DomainGvk = nil
	objToCreate.Spec.FooExampleGvk = nil
	objToCreate.Spec.SvcGrpInfoGvk = nil
	objToCreate.Spec.ACPPoliciesGvk = nil

	var (
		retryCount int
		result     *baseconfigtsmtanzuvmwarecomv1.Config
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateConfigByName] Failed to create Config: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Config: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateConfigByName] context canceled while creating Config: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateConfigByName] Config: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ConfigTsmV1().Configs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateConfigByName] Unable to Get Config %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateConfigByName] found unexpected error while creating Config: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateConfigByName] Config: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateConfigByName] Config: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("roots.root.tsm.tanzu.vmware.com", parentHashedName, "configs.config.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateConfigByName] Executed Successfully: %s", objToCreate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigTsmV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfigtsmtanzuvmwarecomv1.Config) (*ConfigConfig, error) {
	log.Debugf("[UpdateConfigByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Config().GetConfigByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.MyStr0)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.MyStr0).IsNil() {
			patchValueMyStr0 := objToUpdate.Spec.MyStr0
			patchOpMyStr0 := PatchOp{
				Op:    "replace",
				Path:  "/spec/myStr0",
				Value: patchValueMyStr0,
			}
			patch = append(patch, patchOpMyStr0)
		}
	} else {
		patchValueMyStr0 := objToUpdate.Spec.MyStr0
		patchOpMyStr0 := PatchOp{
			Op:    "replace",
			Path:  "/spec/myStr0",
			Value: patchValueMyStr0,
		}
		patch = append(patch, patchOpMyStr0)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.MyStr1)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.MyStr1).IsNil() {
			patchValueMyStr1 := objToUpdate.Spec.MyStr1
			patchOpMyStr1 := PatchOp{
				Op:    "replace",
				Path:  "/spec/myStr1",
				Value: patchValueMyStr1,
			}
			patch = append(patch, patchOpMyStr1)
		}
	} else {
		patchValueMyStr1 := objToUpdate.Spec.MyStr1
		patchOpMyStr1 := PatchOp{
			Op:    "replace",
			Path:  "/spec/myStr1",
			Value: patchValueMyStr1,
		}
		patch = append(patch, patchOpMyStr1)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.MyStr2)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.MyStr2).IsNil() {
			patchValueMyStr2 := objToUpdate.Spec.MyStr2
			patchOpMyStr2 := PatchOp{
				Op:    "replace",
				Path:  "/spec/myStr2",
				Value: patchValueMyStr2,
			}
			patch = append(patch, patchOpMyStr2)
		}
	} else {
		patchValueMyStr2 := objToUpdate.Spec.MyStr2
		patchOpMyStr2 := PatchOp{
			Op:    "replace",
			Path:  "/spec/myStr2",
			Value: patchValueMyStr2,
		}
		patch = append(patch, patchOpMyStr2)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.XYZPort)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.XYZPort).IsNil() {
			patchValueXYZPort := objToUpdate.Spec.XYZPort
			patchOpXYZPort := PatchOp{
				Op:    "replace",
				Path:  "/spec/xYZPort",
				Value: patchValueXYZPort,
			}
			patch = append(patch, patchOpXYZPort)
		}
	} else {
		patchValueXYZPort := objToUpdate.Spec.XYZPort
		patchOpXYZPort := PatchOp{
			Op:    "replace",
			Path:  "/spec/xYZPort",
			Value: patchValueXYZPort,
		}
		patch = append(patch, patchOpXYZPort)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ABCHost)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ABCHost).IsNil() {
			patchValueABCHost := objToUpdate.Spec.ABCHost
			patchOpABCHost := PatchOp{
				Op:    "replace",
				Path:  "/spec/aBCHost",
				Value: patchValueABCHost,
			}
			patch = append(patch, patchOpABCHost)
		}
	} else {
		patchValueABCHost := objToUpdate.Spec.ABCHost
		patchOpABCHost := PatchOp{
			Op:    "replace",
			Path:  "/spec/aBCHost",
			Value: patchValueABCHost,
		}
		patch = append(patch, patchOpABCHost)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ClusterNamespaces)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ClusterNamespaces).IsNil() {
			patchValueClusterNamespaces := objToUpdate.Spec.ClusterNamespaces
			patchOpClusterNamespaces := PatchOp{
				Op:    "replace",
				Path:  "/spec/clusterNamespaces",
				Value: patchValueClusterNamespaces,
			}
			patch = append(patch, patchOpClusterNamespaces)
		}
	} else {
		patchValueClusterNamespaces := objToUpdate.Spec.ClusterNamespaces
		patchOpClusterNamespaces := PatchOp{
			Op:    "replace",
			Path:  "/spec/clusterNamespaces",
			Value: patchValueClusterNamespaces,
		}
		patch = append(patch, patchOpClusterNamespaces)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.TestValMarkers)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.TestValMarkers).IsNil() {
			patchValueTestValMarkers := objToUpdate.Spec.TestValMarkers
			patchOpTestValMarkers := PatchOp{
				Op:    "replace",
				Path:  "/spec/testValMarkers",
				Value: patchValueTestValMarkers,
			}
			patch = append(patch, patchOpTestValMarkers)
		}
	} else {
		patchValueTestValMarkers := objToUpdate.Spec.TestValMarkers
		patchOpTestValMarkers := PatchOp{
			Op:    "replace",
			Path:  "/spec/testValMarkers",
			Value: patchValueTestValMarkers,
		}
		patch = append(patch, patchOpTestValMarkers)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Instance)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Instance).IsNil() {
			patchValueInstance := objToUpdate.Spec.Instance
			patchOpInstance := PatchOp{
				Op:    "replace",
				Path:  "/spec/instance",
				Value: patchValueInstance,
			}
			patch = append(patch, patchOpInstance)
		}
	} else {
		patchValueInstance := objToUpdate.Spec.Instance
		patchOpInstance := PatchOp{
			Op:    "replace",
			Path:  "/spec/instance",
			Value: patchValueInstance,
		}
		patch = append(patch, patchOpInstance)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.CuOption)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.CuOption).IsNil() {
			patchValueCuOption := objToUpdate.Spec.CuOption
			patchOpCuOption := PatchOp{
				Op:    "replace",
				Path:  "/spec/option_cu",
				Value: patchValueCuOption,
			}
			patch = append(patch, patchOpCuOption)
		}
	} else {
		patchValueCuOption := objToUpdate.Spec.CuOption
		patchOpCuOption := PatchOp{
			Op:    "replace",
			Path:  "/spec/option_cu",
			Value: patchValueCuOption,
		}
		patch = append(patch, patchOpCuOption)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseconfigtsmtanzuvmwarecomv1.Config
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			Configs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateConfigByName] Failed to patch Config %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Config: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Config deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateConfigByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateConfigByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Config: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Config Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateConfigByName] Patch Config Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateConfigByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateConfigByName] Executed Successfully %s", objToUpdate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigTsmV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigtsmtanzuvmwarecomv1.Config)
			result[k] = &ConfigConfig{
				client: group.client,
				Config: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigTsmV1().
			Configs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigConfig{
				client: group.client,
				Config: &item,
			}
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfigtsmtanzuvmwarecomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *ConfigConfig) GetParent(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["roots.root.tsm.tanzu.vmware.com"])
	return obj.client.Root().GetRootByName(ctx, hashedName)
}

// GetGNS returns child of given type
func (obj *ConfigConfig) GetGNS(ctx context.Context) (
	result *GnsGns, err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "gnses.gns.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "GNS")
	}
	return obj.client.Gns().GetGnsByName(ctx, children[0])
}

// AddGNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddGNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (result *GnsGns, err error) {
	log.Debugf("[AddGNS] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateGnsByName(ctx, objToCreate)
	log.Debugf("[AddGNS] Gns created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddGNS] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteGNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteGNS(ctx context.Context) (err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "gnses.gns.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteGNS] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Gns().DeleteGnsByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetDNS returns child of given type
func (obj *ConfigConfig) GetDNS(ctx context.Context) (
	result *GnsDns, err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "dnses.gns.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "DNS")
	}
	return obj.client.Gns().GetDnsByName(ctx, children[0])
}

// AddDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddDNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (result *GnsDns, err error) {
	log.Debugf("[AddDNS] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateDnsByName(ctx, objToCreate)
	log.Debugf("[AddDNS] Dns created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddDNS] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteDNS(ctx context.Context) (err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "dnses.gns.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteDNS] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Gns().DeleteDnsByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetVMPPolicies returns child of given type
func (obj *ConfigConfig) GetVMPPolicies(ctx context.Context) (
	result *PolicypkgVMpolicy, err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "VMPPolicies")
	}
	return obj.client.Policypkg().GetVMpolicyByName(ctx, children[0])
}

// AddVMPPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddVMPPolicies(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy) (result *PolicypkgVMpolicy, err error) {
	log.Debugf("[AddVMPPolicies] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Policypkg().CreateVMpolicyByName(ctx, objToCreate)
	log.Debugf("[AddVMPPolicies] VMpolicy created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddVMPPolicies] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteVMPPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteVMPPolicies(ctx context.Context) (err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteVMPPolicies] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Policypkg().DeleteVMpolicyByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetDomain returns child of given type
func (obj *ConfigConfig) GetDomain(ctx context.Context) (
	result *ConfigDomain, err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "domains.config.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "Domain")
	}
	return obj.client.Config().GetDomainByName(ctx, children[0])
}

// AddDomain calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddDomain(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Domain) (result *ConfigDomain, err error) {
	log.Debugf("[AddDomain] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateDomainByName(ctx, objToCreate)
	log.Debugf("[AddDomain] Domain created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddDomain] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteDomain calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteDomain(ctx context.Context) (err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "domains.config.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteDomain] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Config().DeleteDomainByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type ConfigConfigFooExample struct {
	client     *Clientset
	FooExample []baseconfigtsmtanzuvmwarecomv1.Child
}

func (n *ConfigConfigFooExample) Next(ctx context.Context) (*ConfigFooTypeABC, error) {
	for index, child := range n.FooExample {
		obj, err := n.client.Config().GetFooTypeABCByName(ctx, child.Name)
		if err == nil {
			if index == len(n.FooExample)-1 {
				n.FooExample = nil
			} else {
				n.FooExample = n.FooExample[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllFooExampleIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllFooExampleIter(ctx context.Context) (
	result ConfigConfigFooExample) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "footypeabcs.config.tsm.tanzu.vmware.com") {
		result.FooExample = append(result.FooExample, baseconfigtsmtanzuvmwarecomv1.Child{
			Group: "config.tsm.tanzu.vmware.com",
			Kind:  "FooTypeABC",
			Name:  v,
		})
	}
	return
}

// GetAllFooExample returns all children of a given type
func (obj *ConfigConfig) GetAllFooExample(ctx context.Context) (
	result []*ConfigFooTypeABC, err error) {
	for _, v := range GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "footypeabcs.config.tsm.tanzu.vmware.com") {
		l, err := obj.client.Config().GetFooTypeABCByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetFooExample returns child which has given displayName
func (obj *ConfigConfig) GetFooExample(ctx context.Context,
	displayName string) (result *ConfigFooTypeABC, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("footypeabcs.config.tsm.tanzu.vmware.com", parentLabels, displayName)
	if IsChildExists("configs.config.tsm.tanzu.vmware.com", obj.Name, "footypeabcs.config.tsm.tanzu.vmware.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "FooExample", displayName)
	}

	result, err = obj.client.Config().GetFooTypeABCByName(ctx, childHashName)
	return
}

// AddFooExample calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddFooExample(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.FooTypeABC) (result *ConfigFooTypeABC, err error) {
	log.Debugf("[AddFooExample] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateFooTypeABCByName(ctx, objToCreate)
	log.Debugf("[AddFooExample] FooTypeABC created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddFooExample] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteFooExample calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteFooExample(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteFooExample] Received for FooTypeABC object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("footypeabcs.config.tsm.tanzu.vmware.com", parentLabels, displayName)
	if IsChildExists("configs.config.tsm.tanzu.vmware.com", obj.Name, "footypeabcs.config.tsm.tanzu.vmware.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "FooExample", displayName)
	}

	err = obj.client.Config().DeleteFooTypeABCByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteFooExample] FooTypeABC object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetSvcGrpInfo returns child of given type
func (obj *ConfigConfig) GetSvcGrpInfo(ctx context.Context) (
	result *ServicegroupSvcGroupLinkInfo, err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "SvcGrpInfo")
	}
	return obj.client.Servicegroup().GetSvcGroupLinkInfoByName(ctx, children[0])
}

// AddSvcGrpInfo calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddSvcGrpInfo(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo) (result *ServicegroupSvcGroupLinkInfo, err error) {
	log.Debugf("[AddSvcGrpInfo] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Servicegroup().CreateSvcGroupLinkInfoByName(ctx, objToCreate)
	log.Debugf("[AddSvcGrpInfo] SvcGroupLinkInfo created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddSvcGrpInfo] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteSvcGrpInfo calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteSvcGrpInfo(ctx context.Context) (err error) {
	children := GetChildren("configs.config.tsm.tanzu.vmware.com", obj.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteSvcGrpInfo] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Servicegroup().DeleteSvcGroupLinkInfoByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllACPPolicies returns all links of given type
func (obj *ConfigConfig) GetAllACPPolicies(ctx context.Context) (
	result []*PolicypkgAccessControlPolicy, err error) {
	result = make([]*PolicypkgAccessControlPolicy, 0, len(obj.Spec.ACPPoliciesGvk))
	for _, v := range obj.Spec.ACPPoliciesGvk {
		l, err := obj.client.Policypkg().GetAccessControlPolicyByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetACPPolicies returns link which has given displayName
func (obj *ConfigConfig) GetACPPolicies(ctx context.Context,
	displayName string) (result *PolicypkgAccessControlPolicy, err error) {
	l, ok := obj.Spec.ACPPoliciesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Config.Config", "ACPPolicies", displayName)
	}
	result, err = obj.client.Policypkg().GetAccessControlPolicyByName(ctx, l.Name)
	return
}

// LinkACPPolicies links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *ConfigConfig) LinkACPPolicies(ctx context.Context,
	linkToAdd *PolicypkgAccessControlPolicy) error {

	payload := "{\"spec\": {\"aCPPoliciesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"AccessControlPolicy\", \"group\": \"policypkg.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.ConfigTsmV1().Configs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Config = result
	return nil
}

// UnlinkACPPolicies unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *ConfigConfig) UnlinkACPPolicies(ctx context.Context,
	linkToRemove *PolicypkgAccessControlPolicy) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/aCPPoliciesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.ConfigTsmV1().Configs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Config = result
	return nil

}

type configConfigTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigTsmV1Chainer) Subscribe() {
	key := "configs.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *configConfigTsmV1Chainer) Unsubscribe() {
	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *configConfigTsmV1Chainer) IsSubscribed() bool {
	key := "configs.config.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *configConfigTsmV1Chainer) addCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("roots.root.tsm.tanzu.vmware.com", parentHashName, "configs.config.tsm.tanzu.vmware.com", obj.Name)
}

func (c *configConfigTsmV1Chainer) deleteCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("roots.root.tsm.tanzu.vmware.com", parentHashName, "configs.config.tsm.tanzu.vmware.com", obj.Name)
}

func (c *configConfigTsmV1Chainer) RegisterEventHandler(addCB func(obj *ConfigConfig), updateCB func(oldObj, newObj *ConfigConfig), deleteCB func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["roots.root.tsm.tanzu.vmware.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("roots.root.tsm.tanzu.vmware.com", parent.Name, "configs.config.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("roots.root.tsm.tanzu.vmware.com", parent.Name, "configs.config.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigConfig{
				client: c.client,
				Config: oldObj.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}
			newData := &ConfigConfig{
				client: c.client,
				Config: newObj.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["roots.root.tsm.tanzu.vmware.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("roots.root.tsm.tanzu.vmware.com", parent.Name, "configs.config.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("roots.root.tsm.tanzu.vmware.com", parent.Name, "configs.config.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *configConfigTsmV1Chainer) RegisterAddCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["roots.root.tsm.tanzu.vmware.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("roots.root.tsm.tanzu.vmware.com", parent.Name, "configs.config.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("roots.root.tsm.tanzu.vmware.com", parent.Name, "configs.config.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *configConfigTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigConfig{
				client: c.client,
				Config: oldObj.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}
			newData := &ConfigConfig{
				client: c.client,
				Config: newObj.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *configConfigTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigtsmtanzuvmwarecomv1.Config),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["roots.root.tsm.tanzu.vmware.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("roots.root.tsm.tanzu.vmware.com", parent.Name, "configs.config.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("roots.root.tsm.tanzu.vmware.com", parent.Name, "configs.config.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *configConfigTsmV1Chainer) GNS(name string) *gnsGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnses.gns.tsm.tanzu.vmware.com"] = name
	return &gnsGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGNS calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetGNS(ctx context.Context, displayName string) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetGnsByName(ctx, hashedName)
}

// AddGNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddGNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (result *GnsGns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateGnsByName(ctx, objToCreate)
}

// DeleteGNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteGNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteGnsByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) DNS() *dnsGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dnses.gns.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &dnsGnsTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetDNS calculates hashed name of the object based on it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetDNS(ctx context.Context) (result *GnsDns, err error) {
	hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Gns().GetDnsByName(ctx, hashedName)
}

// AddDNS calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddDNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (result *GnsDns, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateDnsByName(ctx, objToCreate)
}

// DeleteDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteDNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteDnsByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) VMPPolicies(name string) *vmpolicyPolicypkgTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["vmpolicies.policypkg.tsm.tanzu.vmware.com"] = name
	return &vmpolicyPolicypkgTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetVMPPolicies calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetVMPPolicies(ctx context.Context, displayName string) (result *PolicypkgVMpolicy, err error) {
	hashedName := helper.GetHashedName("vmpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Policypkg().GetVMpolicyByName(ctx, hashedName)
}

// AddVMPPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddVMPPolicies(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy) (result *PolicypkgVMpolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("vmpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Policypkg().CreateVMpolicyByName(ctx, objToCreate)
}

// DeleteVMPPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteVMPPolicies(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("vmpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Policypkg().DeleteVMpolicyByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) Domain(name string) *domainConfigTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["domains.config.tsm.tanzu.vmware.com"] = name
	return &domainConfigTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDomain calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetDomain(ctx context.Context, displayName string) (result *ConfigDomain, err error) {
	hashedName := helper.GetHashedName("domains.config.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Config().GetDomainByName(ctx, hashedName)
}

// AddDomain calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddDomain(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Domain) (result *ConfigDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("domains.config.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateDomainByName(ctx, objToCreate)
}

// DeleteDomain calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteDomain(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("domains.config.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Config().DeleteDomainByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) FooExample(name string) *footypeabcConfigTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["footypeabcs.config.tsm.tanzu.vmware.com"] = name
	return &footypeabcConfigTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetFooExample calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetFooExample(ctx context.Context, displayName string) (result *ConfigFooTypeABC, err error) {
	hashedName := helper.GetHashedName("footypeabcs.config.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Config().GetFooTypeABCByName(ctx, hashedName)
}

// AddFooExample calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddFooExample(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.FooTypeABC) (result *ConfigFooTypeABC, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("footypeabcs.config.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateFooTypeABCByName(ctx, objToCreate)
}

// DeleteFooExample calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteFooExample(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("footypeabcs.config.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Config().DeleteFooTypeABCByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) SvcGrpInfo(name string) *svcgrouplinkinfoServicegroupTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"] = name
	return &svcgrouplinkinfoServicegroupTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSvcGrpInfo calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetSvcGrpInfo(ctx context.Context, displayName string) (result *ServicegroupSvcGroupLinkInfo, err error) {
	hashedName := helper.GetHashedName("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Servicegroup().GetSvcGroupLinkInfoByName(ctx, hashedName)
}

// AddSvcGrpInfo calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddSvcGrpInfo(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo) (result *ServicegroupSvcGroupLinkInfo, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Servicegroup().CreateSvcGroupLinkInfoByName(ctx, objToCreate)
}

// DeleteSvcGrpInfo calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteSvcGrpInfo(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Servicegroup().DeleteSvcGroupLinkInfoByName(ctx, hashedName)
}

func (group *ConfigTsmV1) GetFooTypeABCChildrenMap() map[string]baseconfigtsmtanzuvmwarecomv1.Child {
	return map[string]baseconfigtsmtanzuvmwarecomv1.Child{}
}

func (group *ConfigTsmV1) GetFooTypeABCChild(grp, kind, name string) baseconfigtsmtanzuvmwarecomv1.Child {
	return baseconfigtsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetFooTypeABCByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) GetFooTypeABCByName(ctx context.Context, hashedName string) (*ConfigFooTypeABC, error) {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetFooTypeABCByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetFooTypeABCByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetFooTypeABCByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ConfigFooTypeABC{
					client:     group.client,
					FooTypeABC: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ConfigFooTypeABC{
				client:     group.client,
				FooTypeABC: resWrCache.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			FooTypeABCs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ConfigFooTypeABC{
				client:     group.client,
				FooTypeABC: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetFooTypeABCByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get FooTypeABCs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetFooTypeABCByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetFooTypeABCByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadFooTypeABCByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) ForceReadFooTypeABCByName(ctx context.Context, hashedName string) (*ConfigFooTypeABC, error) {
	log.Debugf("[ForceReadFooTypeABCByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			FooTypeABCs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadFooTypeABCByName] Failed to Get FooTypeABCs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get FooTypeABCs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadFooTypeABCByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadFooTypeABCByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadFooTypeABCByName] Executed Successfully :%s", hashedName)
			return &ConfigFooTypeABC{
				client:     group.client,
				FooTypeABC: result,
			}, nil
		}
	}
}

// DeleteFooTypeABCByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) DeleteFooTypeABCByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteFooTypeABCByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseconfigtsmtanzuvmwarecomv1.FooTypeABC
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			FooTypeABCs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteFooTypeABCByName] Failed to get FooTypeABCs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get FooTypeABCs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteFooTypeABCByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteFooTypeABCByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteFooTypeABCByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ConfigTsmV1().
			FooTypeABCs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteFooTypeABCByName] failed to delete FooTypeABCs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete FooTypeABCs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteFooTypeABCByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteFooTypeABCByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteFooTypeABCByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("footypeabcs.config.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteFooTypeABCByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentName, "footypeabcs.config.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateFooTypeABCByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigTsmV1) CreateFooTypeABCByName(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.FooTypeABC) (*ConfigFooTypeABC, error) {
	log.Debugf("[CreateFooTypeABCByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseconfigtsmtanzuvmwarecomv1.FooTypeABC
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			FooTypeABCs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateFooTypeABCByName] Failed to create FooTypeABC: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create FooTypeABC: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateFooTypeABCByName] context canceled while creating FooTypeABC: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateFooTypeABCByName] FooTypeABC: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ConfigTsmV1().FooTypeABCs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateFooTypeABCByName] Unable to Get FooTypeABC %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateFooTypeABCByName] found unexpected error while creating FooTypeABC: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateFooTypeABCByName] FooTypeABC: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("footypeabcs.config.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateFooTypeABCByName] FooTypeABC: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashedName, "footypeabcs.config.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateFooTypeABCByName] Executed Successfully: %s", objToCreate.GetName())
	return &ConfigFooTypeABC{
		client:     group.client,
		FooTypeABC: result,
	}, nil
}

// UpdateFooTypeABCByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigTsmV1) UpdateFooTypeABCByName(ctx context.Context,
	objToUpdate *baseconfigtsmtanzuvmwarecomv1.FooTypeABC) (*ConfigFooTypeABC, error) {
	log.Debugf("[UpdateFooTypeABCByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Config().GetFooTypeABCByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["footypeabcs.config.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.FooA)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FooA).IsNil() {
			patchValueFooA := objToUpdate.Spec.FooA
			patchOpFooA := PatchOp{
				Op:    "replace",
				Path:  "/spec/fooA",
				Value: patchValueFooA,
			}
			patch = append(patch, patchOpFooA)
		}
	} else {
		patchValueFooA := objToUpdate.Spec.FooA
		patchOpFooA := PatchOp{
			Op:    "replace",
			Path:  "/spec/fooA",
			Value: patchValueFooA,
		}
		patch = append(patch, patchOpFooA)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.FooB)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FooB).IsNil() {
			patchValueFooB := objToUpdate.Spec.FooB
			patchOpFooB := PatchOp{
				Op:    "replace",
				Path:  "/spec/fooB",
				Value: patchValueFooB,
			}
			patch = append(patch, patchOpFooB)
		}
	} else {
		patchValueFooB := objToUpdate.Spec.FooB
		patchOpFooB := PatchOp{
			Op:    "replace",
			Path:  "/spec/fooB",
			Value: patchValueFooB,
		}
		patch = append(patch, patchOpFooB)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.FooC)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FooC).IsNil() {
			patchValueFooC := objToUpdate.Spec.FooC
			patchOpFooC := PatchOp{
				Op:    "replace",
				Path:  "/spec/fooC",
				Value: patchValueFooC,
			}
			patch = append(patch, patchOpFooC)
		}
	} else {
		patchValueFooC := objToUpdate.Spec.FooC
		patchOpFooC := PatchOp{
			Op:    "replace",
			Path:  "/spec/fooC",
			Value: patchValueFooC,
		}
		patch = append(patch, patchOpFooC)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.FooD)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FooD).IsNil() {
			patchValueFooD := objToUpdate.Spec.FooD
			patchOpFooD := PatchOp{
				Op:    "replace",
				Path:  "/spec/fooD",
				Value: patchValueFooD,
			}
			patch = append(patch, patchOpFooD)
		}
	} else {
		patchValueFooD := objToUpdate.Spec.FooD
		patchOpFooD := PatchOp{
			Op:    "replace",
			Path:  "/spec/fooD",
			Value: patchValueFooD,
		}
		patch = append(patch, patchOpFooD)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.FooE)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FooE).IsNil() {
			patchValueFooE := objToUpdate.Spec.FooE
			patchOpFooE := PatchOp{
				Op:    "replace",
				Path:  "/spec/foo_e",
				Value: patchValueFooE,
			}
			patch = append(patch, patchOpFooE)
		}
	} else {
		patchValueFooE := objToUpdate.Spec.FooE
		patchOpFooE := PatchOp{
			Op:    "replace",
			Path:  "/spec/foo_e",
			Value: patchValueFooE,
		}
		patch = append(patch, patchOpFooE)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.FooF)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FooF).IsNil() {
			patchValueFooF := objToUpdate.Spec.FooF
			patchOpFooF := PatchOp{
				Op:    "replace",
				Path:  "/spec/foo_f",
				Value: patchValueFooF,
			}
			patch = append(patch, patchOpFooF)
		}
	} else {
		patchValueFooF := objToUpdate.Spec.FooF
		patchOpFooF := PatchOp{
			Op:    "replace",
			Path:  "/spec/foo_f",
			Value: patchValueFooF,
		}
		patch = append(patch, patchOpFooF)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseconfigtsmtanzuvmwarecomv1.FooTypeABC
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			FooTypeABCs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateFooTypeABCByName] Failed to patch FooTypeABC %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger FooTypeABC Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteFooTypeABCByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting FooTypeABC: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("FooTypeABC deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateFooTypeABCByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateFooTypeABCByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger FooTypeABC Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteFooTypeABCByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting FooTypeABC: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("FooTypeABC Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateFooTypeABCByName] Patch FooTypeABC Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("footypeabcs.config.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateFooTypeABCByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateFooTypeABCByName] Executed Successfully %s", objToUpdate.GetName())
	return &ConfigFooTypeABC{
		client:     group.client,
		FooTypeABC: result,
	}, nil
}

// ListFooTypeABCs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigTsmV1) ListFooTypeABCs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigFooTypeABC, err error) {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigFooTypeABC, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC)
			result[k] = &ConfigFooTypeABC{
				client:     group.client,
				FooTypeABC: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigTsmV1().
			FooTypeABCs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigFooTypeABC, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigFooTypeABC{
				client:     group.client,
				FooTypeABC: &item,
			}
		}
	}
	return
}

type ConfigFooTypeABC struct {
	client *Clientset
	*baseconfigtsmtanzuvmwarecomv1.FooTypeABC
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigFooTypeABC) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteFooTypeABCByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.FooTypeABC = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigFooTypeABC) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateFooTypeABCByName(ctx, obj.FooTypeABC)
	if err != nil {
		return err
	}
	obj.FooTypeABC = result.FooTypeABC
	return nil
}

func (obj *ConfigFooTypeABC) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type footypeabcConfigTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *footypeabcConfigTsmV1Chainer) Subscribe() {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewFooTypeABCInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *footypeabcConfigTsmV1Chainer) Unsubscribe() {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *footypeabcConfigTsmV1Chainer) IsSubscribed() bool {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *footypeabcConfigTsmV1Chainer) addCallback(obj *ConfigFooTypeABC) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "footypeabcs.config.tsm.tanzu.vmware.com", obj.Name)
}

func (c *footypeabcConfigTsmV1Chainer) deleteCallback(obj *ConfigFooTypeABC) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "footypeabcs.config.tsm.tanzu.vmware.com", obj.Name)
}

func (c *footypeabcConfigTsmV1Chainer) RegisterEventHandler(addCB func(obj *ConfigFooTypeABC), updateCB func(oldObj, newObj *ConfigFooTypeABC), deleteCB func(obj *ConfigFooTypeABC)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ConfigFooTypeABC")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigFooTypeABC")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigFooTypeABC, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewFooTypeABCInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigFooTypeABC{
				client:     c.client,
				FooTypeABC: obj.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "footypeabcs.config.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "footypeabcs.config.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigFooTypeABC{
				client:     c.client,
				FooTypeABC: oldObj.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}
			newData := &ConfigFooTypeABC{
				client:     c.client,
				FooTypeABC: newObj.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ConfigFooTypeABC{
				client:     c.client,
				FooTypeABC: obj.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "footypeabcs.config.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "footypeabcs.config.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *footypeabcConfigTsmV1Chainer) RegisterAddCallback(cbfn func(obj *ConfigFooTypeABC)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for ConfigFooTypeABC")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigFooTypeABC")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigFooTypeABC, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewFooTypeABCInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigFooTypeABC{
				client:     c.client,
				FooTypeABC: obj.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "footypeabcs.config.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "footypeabcs.config.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *footypeabcConfigTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ConfigFooTypeABC)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for ConfigFooTypeABC")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigFooTypeABC")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigFooTypeABC, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewFooTypeABCInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigFooTypeABC{
				client:     c.client,
				FooTypeABC: oldObj.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}
			newData := &ConfigFooTypeABC{
				client:     c.client,
				FooTypeABC: newObj.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *footypeabcConfigTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *ConfigFooTypeABC)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for ConfigFooTypeABC")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigFooTypeABC")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigFooTypeABC, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewFooTypeABCInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ConfigFooTypeABC{
				client:     c.client,
				FooTypeABC: obj.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "footypeabcs.config.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "footypeabcs.config.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *ConfigTsmV1) GetDomainChildrenMap() map[string]baseconfigtsmtanzuvmwarecomv1.Child {
	return map[string]baseconfigtsmtanzuvmwarecomv1.Child{}
}

func (group *ConfigTsmV1) GetDomainChild(grp, kind, name string) baseconfigtsmtanzuvmwarecomv1.Child {
	return baseconfigtsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetDomainByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) GetDomainByName(ctx context.Context, hashedName string) (*ConfigDomain, error) {
	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetDomainByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseconfigtsmtanzuvmwarecomv1.Domain)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetDomainByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseconfigtsmtanzuvmwarecomv1.Domain).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetDomainByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ConfigDomain{
					client: group.client,
					Domain: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ConfigDomain{
				client: group.client,
				Domain: resWrCache.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			Domains().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ConfigDomain{
				client: group.client,
				Domain: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetDomainByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Domains: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetDomainByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetDomainByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadDomainByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) ForceReadDomainByName(ctx context.Context, hashedName string) (*ConfigDomain, error) {
	log.Debugf("[ForceReadDomainByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			Domains().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadDomainByName] Failed to Get Domains: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Domains: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadDomainByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadDomainByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadDomainByName] Executed Successfully :%s", hashedName)
			return &ConfigDomain{
				client: group.client,
				Domain: result,
			}, nil
		}
	}
}

// DeleteDomainByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) DeleteDomainByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteDomainByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseconfigtsmtanzuvmwarecomv1.Domain
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			Domains().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteDomainByName] Failed to get Domains: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Domains: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteDomainByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteDomainByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteDomainByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ConfigTsmV1().
			Domains().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteDomainByName] failed to delete Domains: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Domains: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteDomainByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteDomainByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteDomainByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("domains.config.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteDomainByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentName, "domains.config.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateDomainByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigTsmV1) CreateDomainByName(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Domain) (*ConfigDomain, error) {
	log.Debugf("[CreateDomainByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseconfigtsmtanzuvmwarecomv1.Domain
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			Domains().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateDomainByName] Failed to create Domain: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Domain: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateDomainByName] context canceled while creating Domain: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateDomainByName] Domain: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ConfigTsmV1().Domains().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateDomainByName] Unable to Get Domain %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateDomainByName] found unexpected error while creating Domain: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateDomainByName] Domain: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("domains.config.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateDomainByName] Domain: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashedName, "domains.config.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateDomainByName] Executed Successfully: %s", objToCreate.GetName())
	return &ConfigDomain{
		client: group.client,
		Domain: result,
	}, nil
}

// UpdateDomainByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigTsmV1) UpdateDomainByName(ctx context.Context,
	objToUpdate *baseconfigtsmtanzuvmwarecomv1.Domain) (*ConfigDomain, error) {
	log.Debugf("[UpdateDomainByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Config().GetDomainByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["domains.config.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.PointPort)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PointPort).IsNil() {
			patchValuePointPort := objToUpdate.Spec.PointPort
			patchOpPointPort := PatchOp{
				Op:    "replace",
				Path:  "/spec/pointPort",
				Value: patchValuePointPort,
			}
			patch = append(patch, patchOpPointPort)
		}
	} else {
		patchValuePointPort := objToUpdate.Spec.PointPort
		patchOpPointPort := PatchOp{
			Op:    "replace",
			Path:  "/spec/pointPort",
			Value: patchValuePointPort,
		}
		patch = append(patch, patchOpPointPort)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PointString)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PointString).IsNil() {
			patchValuePointString := objToUpdate.Spec.PointString
			patchOpPointString := PatchOp{
				Op:    "replace",
				Path:  "/spec/pointString",
				Value: patchValuePointString,
			}
			patch = append(patch, patchOpPointString)
		}
	} else {
		patchValuePointString := objToUpdate.Spec.PointString
		patchOpPointString := PatchOp{
			Op:    "replace",
			Path:  "/spec/pointString",
			Value: patchValuePointString,
		}
		patch = append(patch, patchOpPointString)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PointInt)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PointInt).IsNil() {
			patchValuePointInt := objToUpdate.Spec.PointInt
			patchOpPointInt := PatchOp{
				Op:    "replace",
				Path:  "/spec/pointInt",
				Value: patchValuePointInt,
			}
			patch = append(patch, patchOpPointInt)
		}
	} else {
		patchValuePointInt := objToUpdate.Spec.PointInt
		patchOpPointInt := PatchOp{
			Op:    "replace",
			Path:  "/spec/pointInt",
			Value: patchValuePointInt,
		}
		patch = append(patch, patchOpPointInt)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PointMap)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PointMap).IsNil() {
			patchValuePointMap := objToUpdate.Spec.PointMap
			patchOpPointMap := PatchOp{
				Op:    "replace",
				Path:  "/spec/pointMap",
				Value: patchValuePointMap,
			}
			patch = append(patch, patchOpPointMap)
		}
	} else {
		patchValuePointMap := objToUpdate.Spec.PointMap
		patchOpPointMap := PatchOp{
			Op:    "replace",
			Path:  "/spec/pointMap",
			Value: patchValuePointMap,
		}
		patch = append(patch, patchOpPointMap)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PointSlice)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PointSlice).IsNil() {
			patchValuePointSlice := objToUpdate.Spec.PointSlice
			patchOpPointSlice := PatchOp{
				Op:    "replace",
				Path:  "/spec/pointSlice",
				Value: patchValuePointSlice,
			}
			patch = append(patch, patchOpPointSlice)
		}
	} else {
		patchValuePointSlice := objToUpdate.Spec.PointSlice
		patchOpPointSlice := PatchOp{
			Op:    "replace",
			Path:  "/spec/pointSlice",
			Value: patchValuePointSlice,
		}
		patch = append(patch, patchOpPointSlice)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.SliceOfPoints)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.SliceOfPoints).IsNil() {
			patchValueSliceOfPoints := objToUpdate.Spec.SliceOfPoints
			patchOpSliceOfPoints := PatchOp{
				Op:    "replace",
				Path:  "/spec/sliceOfPoints",
				Value: patchValueSliceOfPoints,
			}
			patch = append(patch, patchOpSliceOfPoints)
		}
	} else {
		patchValueSliceOfPoints := objToUpdate.Spec.SliceOfPoints
		patchOpSliceOfPoints := PatchOp{
			Op:    "replace",
			Path:  "/spec/sliceOfPoints",
			Value: patchValueSliceOfPoints,
		}
		patch = append(patch, patchOpSliceOfPoints)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.SliceOfArrPoints)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.SliceOfArrPoints).IsNil() {
			patchValueSliceOfArrPoints := objToUpdate.Spec.SliceOfArrPoints
			patchOpSliceOfArrPoints := PatchOp{
				Op:    "replace",
				Path:  "/spec/sliceOfArrPoints",
				Value: patchValueSliceOfArrPoints,
			}
			patch = append(patch, patchOpSliceOfArrPoints)
		}
	} else {
		patchValueSliceOfArrPoints := objToUpdate.Spec.SliceOfArrPoints
		patchOpSliceOfArrPoints := PatchOp{
			Op:    "replace",
			Path:  "/spec/sliceOfArrPoints",
			Value: patchValueSliceOfArrPoints,
		}
		patch = append(patch, patchOpSliceOfArrPoints)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.MapOfArrsPoints)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.MapOfArrsPoints).IsNil() {
			patchValueMapOfArrsPoints := objToUpdate.Spec.MapOfArrsPoints
			patchOpMapOfArrsPoints := PatchOp{
				Op:    "replace",
				Path:  "/spec/mapOfArrsPoints",
				Value: patchValueMapOfArrsPoints,
			}
			patch = append(patch, patchOpMapOfArrsPoints)
		}
	} else {
		patchValueMapOfArrsPoints := objToUpdate.Spec.MapOfArrsPoints
		patchOpMapOfArrsPoints := PatchOp{
			Op:    "replace",
			Path:  "/spec/mapOfArrsPoints",
			Value: patchValueMapOfArrsPoints,
		}
		patch = append(patch, patchOpMapOfArrsPoints)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PointStruct)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PointStruct).IsNil() {
			patchValuePointStruct := objToUpdate.Spec.PointStruct
			patchOpPointStruct := PatchOp{
				Op:    "replace",
				Path:  "/spec/pointStruct",
				Value: patchValuePointStruct,
			}
			patch = append(patch, patchOpPointStruct)
		}
	} else {
		patchValuePointStruct := objToUpdate.Spec.PointStruct
		patchOpPointStruct := PatchOp{
			Op:    "replace",
			Path:  "/spec/pointStruct",
			Value: patchValuePointStruct,
		}
		patch = append(patch, patchOpPointStruct)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseconfigtsmtanzuvmwarecomv1.Domain
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ConfigTsmV1().
			Domains().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateDomainByName] Failed to patch Domain %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Domain Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteDomainByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Domain: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Domain deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateDomainByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateDomainByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Domain Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteDomainByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Domain: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Domain Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateDomainByName] Patch Domain Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("domains.config.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateDomainByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateDomainByName] Executed Successfully %s", objToUpdate.GetName())
	return &ConfigDomain{
		client: group.client,
		Domain: result,
	}, nil
}

// ListDomains returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigTsmV1) ListDomains(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigDomain, err error) {
	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigDomain, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigtsmtanzuvmwarecomv1.Domain)
			result[k] = &ConfigDomain{
				client: group.client,
				Domain: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigTsmV1().
			Domains().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigDomain, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigDomain{
				client: group.client,
				Domain: &item,
			}
		}
	}
	return
}

type ConfigDomain struct {
	client *Clientset
	*baseconfigtsmtanzuvmwarecomv1.Domain
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigDomain) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteDomainByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Domain = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigDomain) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateDomainByName(ctx, obj.Domain)
	if err != nil {
		return err
	}
	obj.Domain = result.Domain
	return nil
}

func (obj *ConfigDomain) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type domainConfigTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *domainConfigTsmV1Chainer) Subscribe() {
	key := "domains.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewDomainInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *domainConfigTsmV1Chainer) Unsubscribe() {
	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *domainConfigTsmV1Chainer) IsSubscribed() bool {
	key := "domains.config.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *domainConfigTsmV1Chainer) addCallback(obj *ConfigDomain) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "domains.config.tsm.tanzu.vmware.com", obj.Name)
}

func (c *domainConfigTsmV1Chainer) deleteCallback(obj *ConfigDomain) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "domains.config.tsm.tanzu.vmware.com", obj.Name)
}

func (c *domainConfigTsmV1Chainer) RegisterEventHandler(addCB func(obj *ConfigDomain), updateCB func(oldObj, newObj *ConfigDomain), deleteCB func(obj *ConfigDomain)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ConfigDomain")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigDomain")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigDomain, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewDomainInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigDomain{
				client: c.client,
				Domain: obj.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "domains.config.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "domains.config.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigDomain{
				client: c.client,
				Domain: oldObj.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}
			newData := &ConfigDomain{
				client: c.client,
				Domain: newObj.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ConfigDomain{
				client: c.client,
				Domain: obj.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "domains.config.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "domains.config.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *domainConfigTsmV1Chainer) RegisterAddCallback(cbfn func(obj *ConfigDomain)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for ConfigDomain")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigDomain")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigDomain, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewDomainInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigDomain{
				client: c.client,
				Domain: obj.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "domains.config.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "domains.config.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *domainConfigTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ConfigDomain)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for ConfigDomain")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigDomain")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigDomain, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewDomainInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigDomain{
				client: c.client,
				Domain: oldObj.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}
			newData := &ConfigDomain{
				client: c.client,
				Domain: newObj.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *domainConfigTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *ConfigDomain)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for ConfigDomain")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigDomain")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigDomain, so creating a new one")
		informer = informerconfigtsmtanzuvmwarecomv1.NewDomainInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ConfigDomain{
				client: c.client,
				Domain: obj.(*baseconfigtsmtanzuvmwarecomv1.Domain),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "domains.config.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "domains.config.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *GnsTsmV1) GetFooChildrenMap() map[string]basegnstsmtanzuvmwarecomv1.Child {
	return map[string]basegnstsmtanzuvmwarecomv1.Child{}
}

func (group *GnsTsmV1) GetFooChild(grp, kind, name string) basegnstsmtanzuvmwarecomv1.Child {
	return basegnstsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetFooByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetFooByName(ctx context.Context, hashedName string) (*GnsFoo, error) {
	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetFooByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basegnstsmtanzuvmwarecomv1.Foo)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetFooByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basegnstsmtanzuvmwarecomv1.Foo).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetFooByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &GnsFoo{
					client: group.client,
					Foo:    resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &GnsFoo{
				client: group.client,
				Foo:    resWrCache.(*basegnstsmtanzuvmwarecomv1.Foo),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Foos().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &GnsFoo{
				client: group.client,
				Foo:    result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetFooByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Foos: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetFooByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetFooByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadFooByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) ForceReadFooByName(ctx context.Context, hashedName string) (*GnsFoo, error) {
	log.Debugf("[ForceReadFooByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Foos().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadFooByName] Failed to Get Foos: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Foos: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadFooByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadFooByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadFooByName] Executed Successfully :%s", hashedName)
			return &GnsFoo{
				client: group.client,
				Foo:    result,
			}, nil
		}
	}
}

// DeleteFooByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteFooByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteFooByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.Foo
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Foos().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteFooByName] Failed to get Foos: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Foos: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteFooByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteFooByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteFooByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			GnsTsmV1().
			Foos().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteFooByName] failed to delete Foos: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Foos: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteFooByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteFooByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteFooByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("foos.gns.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteFooByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentName, "foos.gns.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateFooByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateFooByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Foo) (*GnsFoo, error) {
	log.Debugf("[CreateFooByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.Foo
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Foos().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateFooByName] Failed to create Foo: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Foo: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateFooByName] context canceled while creating Foo: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateFooByName] Foo: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.GnsTsmV1().Foos().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateFooByName] Unable to Get Foo %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateFooByName] found unexpected error while creating Foo: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateFooByName] Foo: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("foos.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateFooByName] Foo: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashedName, "foos.gns.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateFooByName] Executed Successfully: %s", objToCreate.GetName())
	return &GnsFoo{
		client: group.client,
		Foo:    result,
	}, nil
}

// UpdateFooByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateFooByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Foo) (*GnsFoo, error) {
	log.Debugf("[UpdateFooByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Gns().GetFooByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["foos.gns.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Password)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Password).IsNil() {
			patchValuePassword := objToUpdate.Spec.Password
			patchOpPassword := PatchOp{
				Op:    "replace",
				Path:  "/spec/password",
				Value: patchValuePassword,
			}
			patch = append(patch, patchOpPassword)
		}
	} else {
		patchValuePassword := objToUpdate.Spec.Password
		patchOpPassword := PatchOp{
			Op:    "replace",
			Path:  "/spec/password",
			Value: patchValuePassword,
		}
		patch = append(patch, patchOpPassword)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basegnstsmtanzuvmwarecomv1.Foo
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Foos().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateFooByName] Failed to patch Foo %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Foo Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteFooByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Foo: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Foo deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateFooByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateFooByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Foo Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteFooByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Foo: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Foo Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateFooByName] Patch Foo Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("foos.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateFooByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateFooByName] Executed Successfully %s", objToUpdate.GetName())
	return &GnsFoo{
		client: group.client,
		Foo:    result,
	}, nil
}

// ListFoos returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListFoos(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsFoo, err error) {
	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsFoo, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.Foo)
			result[k] = &GnsFoo{
				client: group.client,
				Foo:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			Foos().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsFoo, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsFoo{
				client: group.client,
				Foo:    &item,
			}
		}
	}
	return
}

type GnsFoo struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Foo
}

// Delete removes obj and all it's children from the database.
func (obj *GnsFoo) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteFooByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Foo = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsFoo) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateFooByName(ctx, obj.Foo)
	if err != nil {
		return err
	}
	obj.Foo = result.Foo
	return nil
}

func (obj *GnsFoo) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type fooGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *fooGnsTsmV1Chainer) Subscribe() {
	key := "foos.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewFooInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *fooGnsTsmV1Chainer) Unsubscribe() {
	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *fooGnsTsmV1Chainer) IsSubscribed() bool {
	key := "foos.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *fooGnsTsmV1Chainer) addCallback(obj *GnsFoo) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "foos.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *fooGnsTsmV1Chainer) deleteCallback(obj *GnsFoo) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "foos.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *fooGnsTsmV1Chainer) RegisterEventHandler(addCB func(obj *GnsFoo), updateCB func(oldObj, newObj *GnsFoo), deleteCB func(obj *GnsFoo)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for GnsFoo")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsFoo")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsFoo, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewFooInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsFoo{
				client: c.client,
				Foo:    obj.(*basegnstsmtanzuvmwarecomv1.Foo),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "foos.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "foos.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsFoo{
				client: c.client,
				Foo:    oldObj.(*basegnstsmtanzuvmwarecomv1.Foo),
			}
			newData := &GnsFoo{
				client: c.client,
				Foo:    newObj.(*basegnstsmtanzuvmwarecomv1.Foo),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &GnsFoo{
				client: c.client,
				Foo:    obj.(*basegnstsmtanzuvmwarecomv1.Foo),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "foos.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "foos.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *fooGnsTsmV1Chainer) RegisterAddCallback(cbfn func(obj *GnsFoo)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for GnsFoo")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsFoo")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsFoo, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewFooInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsFoo{
				client: c.client,
				Foo:    obj.(*basegnstsmtanzuvmwarecomv1.Foo),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "foos.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "foos.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *fooGnsTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *GnsFoo)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for GnsFoo")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsFoo")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsFoo, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewFooInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsFoo{
				client: c.client,
				Foo:    oldObj.(*basegnstsmtanzuvmwarecomv1.Foo),
			}
			newData := &GnsFoo{
				client: c.client,
				Foo:    newObj.(*basegnstsmtanzuvmwarecomv1.Foo),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *fooGnsTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *GnsFoo)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for GnsFoo")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsFoo")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsFoo, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewFooInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &GnsFoo{
				client: c.client,
				Foo:    obj.(*basegnstsmtanzuvmwarecomv1.Foo),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "foos.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "foos.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *GnsTsmV1) GetGnsChildrenMap() map[string]basegnstsmtanzuvmwarecomv1.Child {
	return map[string]basegnstsmtanzuvmwarecomv1.Child{}
}

func (group *GnsTsmV1) GetGnsChild(grp, kind, name string) basegnstsmtanzuvmwarecomv1.Child {
	return basegnstsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetGnsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetGnsByName(ctx context.Context, hashedName string) (*GnsGns, error) {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetGnsByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basegnstsmtanzuvmwarecomv1.Gns)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetGnsByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basegnstsmtanzuvmwarecomv1.Gns).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetGnsByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &GnsGns{
					client: group.client,
					Gns:    resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &GnsGns{
				client: group.client,
				Gns:    resWrCache.(*basegnstsmtanzuvmwarecomv1.Gns),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Gnses().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &GnsGns{
				client: group.client,
				Gns:    result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetGnsByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Gnses: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetGnsByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetGnsByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadGnsByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) ForceReadGnsByName(ctx context.Context, hashedName string) (*GnsGns, error) {
	log.Debugf("[ForceReadGnsByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Gnses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadGnsByName] Failed to Get Gnses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Gnses: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadGnsByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadGnsByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadGnsByName] Executed Successfully :%s", hashedName)
			return &GnsGns{
				client: group.client,
				Gns:    result,
			}, nil
		}
	}
}

// DeleteGnsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteGnsByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteGnsByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.Gns
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Gnses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteGnsByName] Failed to get Gnses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Gnses: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteGnsByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteGnsByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteGnsByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("gnses.gns.tsm.tanzu.vmware.com", hashedName, "svcgroups.servicegroup.tsm.tanzu.vmware.com") {
		err := group.client.Servicegroup().DeleteSvcGroupByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("gnses.gns.tsm.tanzu.vmware.com", hashedName, "svcgroups.servicegroup.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("gnses.gns.tsm.tanzu.vmware.com", hashedName, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com") {
		err := group.client.Policypkg().DeleteAccessControlPolicyByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("gnses.gns.tsm.tanzu.vmware.com", hashedName, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("gnses.gns.tsm.tanzu.vmware.com", hashedName, "barchilds.gns.tsm.tanzu.vmware.com") {
		err := group.client.Gns().DeleteBarChildByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("gnses.gns.tsm.tanzu.vmware.com", hashedName, "barchilds.gns.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("gnses.gns.tsm.tanzu.vmware.com", hashedName, "ignorechilds.gns.tsm.tanzu.vmware.com") {
		err := group.client.Gns().DeleteIgnoreChildByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("gnses.gns.tsm.tanzu.vmware.com", hashedName, "ignorechilds.gns.tsm.tanzu.vmware.com", child)
	}

	for _, child := range GetChildren("gnses.gns.tsm.tanzu.vmware.com", hashedName, "foos.gns.tsm.tanzu.vmware.com") {
		err := group.client.Gns().DeleteFooByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("gnses.gns.tsm.tanzu.vmware.com", hashedName, "foos.gns.tsm.tanzu.vmware.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			GnsTsmV1().
			Gnses().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteGnsByName] failed to delete Gnses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Gnses: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteGnsByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteGnsByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteGnsByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("gnses.gns.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteGnsByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentName, "gnses.gns.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateGnsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateGnsByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (*GnsGns, error) {
	log.Debugf("[CreateGnsByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	log.Debugf("[CreateGnsByName] Node is marked for deferred delete: %s", objToCreate.GetName())
	found := false
	for _, finalizer := range objToCreate.Finalizers {
		if finalizer == nexusDeferredDeleteAnnotation {
			found = true
			break
		}
	}
	if !found {
		objToCreate.Finalizers = append(objToCreate.Finalizers, nexusDeferredDeleteAnnotation)
		log.Debugf("[CreateGnsByName] Added %s finalizer to node: %s", nexusDeferredDeleteAnnotation, objToCreate.GetName())
	}

	objToCreate.Spec.GnsServiceGroupsGvk = nil
	objToCreate.Spec.GnsAccessControlPolicyGvk = nil
	objToCreate.Spec.FooChildGvk = nil
	objToCreate.Spec.IgnoreChildGvk = nil
	objToCreate.Spec.FooGvk = nil
	objToCreate.Spec.DnsGvk = nil

	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.Gns
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Gnses().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateGnsByName] Failed to create Gns: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Gns: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateGnsByName] context canceled while creating Gns: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateGnsByName] Gns: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.GnsTsmV1().Gnses().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateGnsByName] Unable to Get Gns %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateGnsByName] found unexpected error while creating Gns: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateGnsByName] Gns: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("gnses.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateGnsByName] Gns: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashedName, "gnses.gns.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateGnsByName] Executed Successfully: %s", objToCreate.GetName())
	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// SetGnsStateByName sets user defined status
func (group *GnsTsmV1) SetGnsStateByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Gns, status *basegnstsmtanzuvmwarecomv1.GnsState) (*GnsGns, error) {
	log.Debugf("[SetGnsStateByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "gns.tsm.tanzu.vmware.com",
		Version:  "v1",
		Resource: strings.ToLower("Gnses"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := basegnstsmtanzuvmwarecomv1.Gns{}
	obj.Kind = strings.ToLower("Gnses")
	obj.APIVersion = "gns.tsm.tanzu.vmware.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.State = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.dynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			log.Debugf("[SetGnsStateByName] Updating status for Gns node %s successful", hashedName)
			break
		}

		log.Errorf("[SetGnsStateByName] Updating status for Gns node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadGnsByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			log.Fatalf("[SetGnsStateByName] Max retry exceeded for updating status for Gns node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("gnses.gns.tsm.tanzu.vmware.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *basegnstsmtanzuvmwarecomv1.Gns
			if inWrCache {
				objectToWrite = resWrCache.(*basegnstsmtanzuvmwarecomv1.Gns)
				objectToWrite.Status.State = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.State = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &GnsGns{
		client: group.client,
		Gns:    objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateGnsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateGnsByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Gns) (*GnsGns, error) {
	log.Debugf("[UpdateGnsByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Gns().GetGnsByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Domain)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Domain).IsNil() {
			patchValueDomain := objToUpdate.Spec.Domain
			patchOpDomain := PatchOp{
				Op:    "replace",
				Path:  "/spec/domain",
				Value: patchValueDomain,
			}
			patch = append(patch, patchOpDomain)
		}
	} else {
		patchValueDomain := objToUpdate.Spec.Domain
		patchOpDomain := PatchOp{
			Op:    "replace",
			Path:  "/spec/domain",
			Value: patchValueDomain,
		}
		patch = append(patch, patchOpDomain)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.UseSharedGateway)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.UseSharedGateway).IsNil() {
			patchValueUseSharedGateway := objToUpdate.Spec.UseSharedGateway
			patchOpUseSharedGateway := PatchOp{
				Op:    "replace",
				Path:  "/spec/useSharedGateway",
				Value: patchValueUseSharedGateway,
			}
			patch = append(patch, patchOpUseSharedGateway)
		}
	} else {
		patchValueUseSharedGateway := objToUpdate.Spec.UseSharedGateway
		patchOpUseSharedGateway := PatchOp{
			Op:    "replace",
			Path:  "/spec/useSharedGateway",
			Value: patchValueUseSharedGateway,
		}
		patch = append(patch, patchOpUseSharedGateway)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Annotations)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Annotations).IsNil() {
			patchValueAnnotations := objToUpdate.Spec.Annotations
			patchOpAnnotations := PatchOp{
				Op:    "replace",
				Path:  "/spec/annotations",
				Value: patchValueAnnotations,
			}
			patch = append(patch, patchOpAnnotations)
		}
	} else {
		patchValueAnnotations := objToUpdate.Spec.Annotations
		patchOpAnnotations := PatchOp{
			Op:    "replace",
			Path:  "/spec/annotations",
			Value: patchValueAnnotations,
		}
		patch = append(patch, patchOpAnnotations)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.TargetPort)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.TargetPort).IsNil() {
			patchValueTargetPort := objToUpdate.Spec.TargetPort
			patchOpTargetPort := PatchOp{
				Op:    "replace",
				Path:  "/spec/targetPort",
				Value: patchValueTargetPort,
			}
			patch = append(patch, patchOpTargetPort)
		}
	} else {
		patchValueTargetPort := objToUpdate.Spec.TargetPort
		patchOpTargetPort := PatchOp{
			Op:    "replace",
			Path:  "/spec/targetPort",
			Value: patchValueTargetPort,
		}
		patch = append(patch, patchOpTargetPort)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Meta)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Meta).IsNil() {
			patchValueMeta := objToUpdate.Spec.Meta
			patchOpMeta := PatchOp{
				Op:    "replace",
				Path:  "/spec/meta",
				Value: patchValueMeta,
			}
			patch = append(patch, patchOpMeta)
		}
	} else {
		patchValueMeta := objToUpdate.Spec.Meta
		patchOpMeta := PatchOp{
			Op:    "replace",
			Path:  "/spec/meta",
			Value: patchValueMeta,
		}
		patch = append(patch, patchOpMeta)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.IntOrString)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.IntOrString).IsNil() {
			patchValueIntOrString := objToUpdate.Spec.IntOrString
			patchOpIntOrString := PatchOp{
				Op:    "replace",
				Path:  "/spec/intOrString",
				Value: patchValueIntOrString,
			}
			patch = append(patch, patchOpIntOrString)
		}
	} else {
		patchValueIntOrString := objToUpdate.Spec.IntOrString
		patchOpIntOrString := PatchOp{
			Op:    "replace",
			Path:  "/spec/intOrString",
			Value: patchValueIntOrString,
		}
		patch = append(patch, patchOpIntOrString)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Port)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Port).IsNil() {
			patchValuePort := objToUpdate.Spec.Port
			patchOpPort := PatchOp{
				Op:    "replace",
				Path:  "/spec/port",
				Value: patchValuePort,
			}
			patch = append(patch, patchOpPort)
		}
	} else {
		patchValuePort := objToUpdate.Spec.Port
		patchOpPort := PatchOp{
			Op:    "replace",
			Path:  "/spec/port",
			Value: patchValuePort,
		}
		patch = append(patch, patchOpPort)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.OtherDescription)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.OtherDescription).IsNil() {
			patchValueOtherDescription := objToUpdate.Spec.OtherDescription
			patchOpOtherDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/otherDescription",
				Value: patchValueOtherDescription,
			}
			patch = append(patch, patchOpOtherDescription)
		}
	} else {
		patchValueOtherDescription := objToUpdate.Spec.OtherDescription
		patchOpOtherDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/otherDescription",
			Value: patchValueOtherDescription,
		}
		patch = append(patch, patchOpOtherDescription)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.MapPointer)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.MapPointer).IsNil() {
			patchValueMapPointer := objToUpdate.Spec.MapPointer
			patchOpMapPointer := PatchOp{
				Op:    "replace",
				Path:  "/spec/mapPointer",
				Value: patchValueMapPointer,
			}
			patch = append(patch, patchOpMapPointer)
		}
	} else {
		patchValueMapPointer := objToUpdate.Spec.MapPointer
		patchOpMapPointer := PatchOp{
			Op:    "replace",
			Path:  "/spec/mapPointer",
			Value: patchValueMapPointer,
		}
		patch = append(patch, patchOpMapPointer)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.SlicePointer)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.SlicePointer).IsNil() {
			patchValueSlicePointer := objToUpdate.Spec.SlicePointer
			patchOpSlicePointer := PatchOp{
				Op:    "replace",
				Path:  "/spec/slicePointer",
				Value: patchValueSlicePointer,
			}
			patch = append(patch, patchOpSlicePointer)
		}
	} else {
		patchValueSlicePointer := objToUpdate.Spec.SlicePointer
		patchOpSlicePointer := PatchOp{
			Op:    "replace",
			Path:  "/spec/slicePointer",
			Value: patchValueSlicePointer,
		}
		patch = append(patch, patchOpSlicePointer)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.WorkloadSpec)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.WorkloadSpec).IsNil() {
			patchValueWorkloadSpec := objToUpdate.Spec.WorkloadSpec
			patchOpWorkloadSpec := PatchOp{
				Op:    "replace",
				Path:  "/spec/workloadSpec",
				Value: patchValueWorkloadSpec,
			}
			patch = append(patch, patchOpWorkloadSpec)
		}
	} else {
		patchValueWorkloadSpec := objToUpdate.Spec.WorkloadSpec
		patchOpWorkloadSpec := PatchOp{
			Op:    "replace",
			Path:  "/spec/workloadSpec",
			Value: patchValueWorkloadSpec,
		}
		patch = append(patch, patchOpWorkloadSpec)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.DifferentSpec)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.DifferentSpec).IsNil() {
			patchValueDifferentSpec := objToUpdate.Spec.DifferentSpec
			patchOpDifferentSpec := PatchOp{
				Op:    "replace",
				Path:  "/spec/differentSpec",
				Value: patchValueDifferentSpec,
			}
			patch = append(patch, patchOpDifferentSpec)
		}
	} else {
		patchValueDifferentSpec := objToUpdate.Spec.DifferentSpec
		patchOpDifferentSpec := PatchOp{
			Op:    "replace",
			Path:  "/spec/differentSpec",
			Value: patchValueDifferentSpec,
		}
		patch = append(patch, patchOpDifferentSpec)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ServiceSegmentRef)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ServiceSegmentRef).IsNil() {
			patchValueServiceSegmentRef := objToUpdate.Spec.ServiceSegmentRef
			patchOpServiceSegmentRef := PatchOp{
				Op:    "replace",
				Path:  "/spec/serviceSegmentRef",
				Value: patchValueServiceSegmentRef,
			}
			patch = append(patch, patchOpServiceSegmentRef)
		}
	} else {
		patchValueServiceSegmentRef := objToUpdate.Spec.ServiceSegmentRef
		patchOpServiceSegmentRef := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceSegmentRef",
			Value: patchValueServiceSegmentRef,
		}
		patch = append(patch, patchOpServiceSegmentRef)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ServiceSegmentRefPointer)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ServiceSegmentRefPointer).IsNil() {
			patchValueServiceSegmentRefPointer := objToUpdate.Spec.ServiceSegmentRefPointer
			patchOpServiceSegmentRefPointer := PatchOp{
				Op:    "replace",
				Path:  "/spec/serviceSegmentRefPointer",
				Value: patchValueServiceSegmentRefPointer,
			}
			patch = append(patch, patchOpServiceSegmentRefPointer)
		}
	} else {
		patchValueServiceSegmentRefPointer := objToUpdate.Spec.ServiceSegmentRefPointer
		patchOpServiceSegmentRefPointer := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceSegmentRefPointer",
			Value: patchValueServiceSegmentRefPointer,
		}
		patch = append(patch, patchOpServiceSegmentRefPointer)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ServiceSegmentRefs)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ServiceSegmentRefs).IsNil() {
			patchValueServiceSegmentRefs := objToUpdate.Spec.ServiceSegmentRefs
			patchOpServiceSegmentRefs := PatchOp{
				Op:    "replace",
				Path:  "/spec/serviceSegmentRefs",
				Value: patchValueServiceSegmentRefs,
			}
			patch = append(patch, patchOpServiceSegmentRefs)
		}
	} else {
		patchValueServiceSegmentRefs := objToUpdate.Spec.ServiceSegmentRefs
		patchOpServiceSegmentRefs := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceSegmentRefs",
			Value: patchValueServiceSegmentRefs,
		}
		patch = append(patch, patchOpServiceSegmentRefs)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ServiceSegmentRefMap)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ServiceSegmentRefMap).IsNil() {
			patchValueServiceSegmentRefMap := objToUpdate.Spec.ServiceSegmentRefMap
			patchOpServiceSegmentRefMap := PatchOp{
				Op:    "replace",
				Path:  "/spec/serviceSegmentRefMap",
				Value: patchValueServiceSegmentRefMap,
			}
			patch = append(patch, patchOpServiceSegmentRefMap)
		}
	} else {
		patchValueServiceSegmentRefMap := objToUpdate.Spec.ServiceSegmentRefMap
		patchOpServiceSegmentRefMap := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceSegmentRefMap",
			Value: patchValueServiceSegmentRefMap,
		}
		patch = append(patch, patchOpServiceSegmentRefMap)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basegnstsmtanzuvmwarecomv1.Gns
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Gnses().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateGnsByName] Failed to patch Gns %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Gns Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteGnsByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Gns: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Gns deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateGnsByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateGnsByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Gns Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteGnsByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Gns: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Gns Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateGnsByName] Patch Gns Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("gnses.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateGnsByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateGnsByName] Executed Successfully %s", objToUpdate.GetName())
	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// ListGnses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListGnses(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsGns, err error) {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsGns, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.Gns)
			result[k] = &GnsGns{
				client: group.client,
				Gns:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			Gnses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsGns, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsGns{
				client: group.client,
				Gns:    &item,
			}
		}
	}
	return
}

type GnsGns struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Gns
}

// Delete removes obj and all it's children from the database.
func (obj *GnsGns) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteGnsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Gns = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsGns) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateGnsByName(ctx, obj.Gns)
	if err != nil {
		return err
	}
	obj.Gns = result.Gns
	return nil
}

// SetState sets user defined status
func (obj *GnsGns) SetState(ctx context.Context, status *basegnstsmtanzuvmwarecomv1.GnsState) error {
	result, err := obj.client.Gns().SetGnsStateByName(ctx, obj.Gns, status)
	if err != nil {
		return err
	}
	obj.Gns = result.Gns
	return nil
}

// GetState to get user defined status
func (obj *GnsGns) GetState(ctx context.Context) (*basegnstsmtanzuvmwarecomv1.GnsState, error) {
	getObj, err := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.State, nil
}

// ClearState to clear user defined status
func (obj *GnsGns) ClearState(ctx context.Context) error {
	result, err := obj.client.Gns().SetGnsStateByName(ctx, obj.Gns, &basegnstsmtanzuvmwarecomv1.GnsState{})
	if err != nil {
		return err
	}
	obj.Gns = result.Gns
	return nil
}

func (obj *GnsGns) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type GnsGnsGnsServiceGroups struct {
	client           *Clientset
	GnsServiceGroups []basegnstsmtanzuvmwarecomv1.Child
}

func (n *GnsGnsGnsServiceGroups) Next(ctx context.Context) (*ServicegroupSvcGroup, error) {
	for index, child := range n.GnsServiceGroups {
		obj, err := n.client.Servicegroup().GetSvcGroupByName(ctx, child.Name)
		if err == nil {
			if index == len(n.GnsServiceGroups)-1 {
				n.GnsServiceGroups = nil
			} else {
				n.GnsServiceGroups = n.GnsServiceGroups[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllGnsServiceGroupsIter returns an iterator for all children of given type
func (obj *GnsGns) GetAllGnsServiceGroupsIter(ctx context.Context) (
	result GnsGnsGnsServiceGroups) {
	result.client = obj.client
	for _, v := range GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com") {
		result.GnsServiceGroups = append(result.GnsServiceGroups, basegnstsmtanzuvmwarecomv1.Child{
			Group: "servicegroup.tsm.tanzu.vmware.com",
			Kind:  "SvcGroup",
			Name:  v,
		})
	}
	return
}

// GetAllGnsServiceGroups returns all children of a given type
func (obj *GnsGns) GetAllGnsServiceGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	for _, v := range GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com") {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsServiceGroups returns child which has given displayName
func (obj *GnsGns) GetGnsServiceGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", parentLabels, displayName)
	if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "GnsServiceGroups", displayName)
	}

	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, childHashName)
	return
}

// AddGnsServiceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddGnsServiceGroups(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (result *ServicegroupSvcGroup, err error) {
	log.Debugf("[AddGnsServiceGroups] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Servicegroup().CreateSvcGroupByName(ctx, objToCreate)
	log.Debugf("[AddGnsServiceGroups] SvcGroup created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	log.Debugf("[AddGnsServiceGroups] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteGnsServiceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteGnsServiceGroups(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteGnsServiceGroups] Received for SvcGroup object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", parentLabels, displayName)
	if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Gns.Gns", "GnsServiceGroups", displayName)
	}

	err = obj.client.Servicegroup().DeleteSvcGroupByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteGnsServiceGroups] SvcGroup object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetGnsAccessControlPolicy returns child of given type
func (obj *GnsGns) GetGnsAccessControlPolicy(ctx context.Context) (
	result *PolicypkgAccessControlPolicy, err error) {
	children := GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "GnsAccessControlPolicy")
	}
	return obj.client.Policypkg().GetAccessControlPolicyByName(ctx, children[0])
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy) (result *PolicypkgAccessControlPolicy, err error) {
	log.Debugf("[AddGnsAccessControlPolicy] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Policypkg().CreateAccessControlPolicyByName(ctx, objToCreate)
	log.Debugf("[AddGnsAccessControlPolicy] AccessControlPolicy created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	log.Debugf("[AddGnsAccessControlPolicy] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteGnsAccessControlPolicy(ctx context.Context) (err error) {
	children := GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteGnsAccessControlPolicy] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Policypkg().DeleteAccessControlPolicyByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetFooChild returns child of given type
func (obj *GnsGns) GetFooChild(ctx context.Context) (
	result *GnsBarChild, err error) {
	children := GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "barchilds.gns.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "FooChild")
	}
	return obj.client.Gns().GetBarChildByName(ctx, children[0])
}

// AddFooChild calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddFooChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (result *GnsBarChild, err error) {
	log.Debugf("[AddFooChild] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateBarChildByName(ctx, objToCreate)
	log.Debugf("[AddFooChild] BarChild created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	log.Debugf("[AddFooChild] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteFooChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteFooChild(ctx context.Context) (err error) {
	children := GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "barchilds.gns.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteFooChild] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Gns().DeleteBarChildByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetIgnoreChild returns child of given type
func (obj *GnsGns) GetIgnoreChild(ctx context.Context) (
	result *GnsIgnoreChild, err error) {
	children := GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "ignorechilds.gns.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "IgnoreChild")
	}
	return obj.client.Gns().GetIgnoreChildByName(ctx, children[0])
}

// AddIgnoreChild calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddIgnoreChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.IgnoreChild) (result *GnsIgnoreChild, err error) {
	log.Debugf("[AddIgnoreChild] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateIgnoreChildByName(ctx, objToCreate)
	log.Debugf("[AddIgnoreChild] IgnoreChild created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	log.Debugf("[AddIgnoreChild] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteIgnoreChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteIgnoreChild(ctx context.Context) (err error) {
	children := GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "ignorechilds.gns.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteIgnoreChild] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Gns().DeleteIgnoreChildByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetFoo returns child of given type
func (obj *GnsGns) GetFoo(ctx context.Context) (
	result *GnsFoo, err error) {
	children := GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "foos.gns.tsm.tanzu.vmware.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "Foo")
	}
	return obj.client.Gns().GetFooByName(ctx, children[0])
}

// AddFoo calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddFoo(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Foo) (result *GnsFoo, err error) {
	log.Debugf("[AddFoo] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateFooByName(ctx, objToCreate)
	log.Debugf("[AddFoo] Foo created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	log.Debugf("[AddFoo] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteFoo calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteFoo(ctx context.Context) (err error) {
	children := GetChildren("gnses.gns.tsm.tanzu.vmware.com", obj.Name, "foos.gns.tsm.tanzu.vmware.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteFoo] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Gns().DeleteFooByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetDns returns link of given type
func (obj *GnsGns) GetDns(ctx context.Context) (
	result *GnsDns, err error) {
	if obj.Spec.DnsGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Gns.Gns", "Dns")
	}
	return obj.client.Gns().GetDnsByName(ctx, obj.Spec.DnsGvk.Name)
}

// LinkDns links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GnsGns) LinkDns(ctx context.Context,
	linkToAdd *GnsDns) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/dnsGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Dns",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Gns = result
	return nil
}

// UnlinkDns unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GnsGns) UnlinkDns(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Gns = result
	return nil

}

type gnsGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsGnsTsmV1Chainer) Subscribe() {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewGnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *gnsGnsTsmV1Chainer) Unsubscribe() {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsGnsTsmV1Chainer) IsSubscribed() bool {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *gnsGnsTsmV1Chainer) addCallback(obj *GnsGns) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "gnses.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *gnsGnsTsmV1Chainer) deleteCallback(obj *GnsGns) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "gnses.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *gnsGnsTsmV1Chainer) RegisterEventHandler(addCB func(obj *GnsGns), updateCB func(oldObj, newObj *GnsGns), deleteCB func(obj *GnsGns)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for GnsGns")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsGns")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsGns, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewGnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsGns{
				client: c.client,
				Gns:    obj.(*basegnstsmtanzuvmwarecomv1.Gns),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "gnses.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "gnses.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsGns{
				client: c.client,
				Gns:    oldObj.(*basegnstsmtanzuvmwarecomv1.Gns),
			}
			newData := &GnsGns{
				client: c.client,
				Gns:    newObj.(*basegnstsmtanzuvmwarecomv1.Gns),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &GnsGns{
				client: c.client,
				Gns:    obj.(*basegnstsmtanzuvmwarecomv1.Gns),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "gnses.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "gnses.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *gnsGnsTsmV1Chainer) RegisterAddCallback(cbfn func(obj *GnsGns)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for GnsGns")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsGns")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsGns, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewGnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsGns{
				client: c.client,
				Gns:    obj.(*basegnstsmtanzuvmwarecomv1.Gns),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "gnses.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "gnses.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *gnsGnsTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *GnsGns)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for GnsGns")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsGns")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsGns, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewGnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsGns{
				client: c.client,
				Gns:    oldObj.(*basegnstsmtanzuvmwarecomv1.Gns),
			}
			newData := &GnsGns{
				client: c.client,
				Gns:    newObj.(*basegnstsmtanzuvmwarecomv1.Gns),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *gnsGnsTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *GnsGns)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for GnsGns")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsGns")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsGns, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewGnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &GnsGns{
				client: c.client,
				Gns:    obj.(*basegnstsmtanzuvmwarecomv1.Gns),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "gnses.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "gnses.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

// ClearState to clear user defined status
func (c *gnsGnsTsmV1Chainer) ClearState(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetGnsByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Gns().SetGnsStateByName(ctx, obj.Gns, nil)
	return err
}

// GetState to get user defined status
func (c *gnsGnsTsmV1Chainer) GetState(ctx context.Context) (result *basegnstsmtanzuvmwarecomv1.GnsState, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetGnsByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.State, nil
}

// SetState sets user defined status
func (c *gnsGnsTsmV1Chainer) SetState(ctx context.Context, status *basegnstsmtanzuvmwarecomv1.GnsState) (err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetGnsByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Gns().SetGnsStateByName(ctx, obj.Gns, status)
	return err
}

func (c *gnsGnsTsmV1Chainer) GnsServiceGroups(name string) *svcgroupServicegroupTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["svcgroups.servicegroup.tsm.tanzu.vmware.com"] = name
	return &svcgroupServicegroupTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsServiceGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetGnsServiceGroups(ctx context.Context, displayName string) (result *ServicegroupSvcGroup, err error) {
	hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Servicegroup().GetSvcGroupByName(ctx, hashedName)
}

// AddGnsServiceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddGnsServiceGroups(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (result *ServicegroupSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Servicegroup().CreateSvcGroupByName(ctx, objToCreate)
}

// DeleteGnsServiceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteGnsServiceGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Servicegroup().DeleteSvcGroupByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) GnsAccessControlPolicy(name string) *accesscontrolpolicyPolicypkgTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"] = name
	return &accesscontrolpolicyPolicypkgTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsAccessControlPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetGnsAccessControlPolicy(ctx context.Context, displayName string) (result *PolicypkgAccessControlPolicy, err error) {
	hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Policypkg().GetAccessControlPolicyByName(ctx, hashedName)
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy) (result *PolicypkgAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Policypkg().CreateAccessControlPolicyByName(ctx, objToCreate)
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteGnsAccessControlPolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Policypkg().DeleteAccessControlPolicyByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) FooChild() *barchildGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["barchilds.gns.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &barchildGnsTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetFooChild calculates hashed name of the object based on it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetFooChild(ctx context.Context) (result *GnsBarChild, err error) {
	hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Gns().GetBarChildByName(ctx, hashedName)
}

// AddFooChild calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddFooChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (result *GnsBarChild, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateBarChildByName(ctx, objToCreate)
}

// DeleteFooChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteFooChild(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteBarChildByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) IgnoreChild(name string) *ignorechildGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["ignorechilds.gns.tsm.tanzu.vmware.com"] = name
	return &ignorechildGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetIgnoreChild calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetIgnoreChild(ctx context.Context, displayName string) (result *GnsIgnoreChild, err error) {
	hashedName := helper.GetHashedName("ignorechilds.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetIgnoreChildByName(ctx, hashedName)
}

// AddIgnoreChild calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddIgnoreChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.IgnoreChild) (result *GnsIgnoreChild, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("ignorechilds.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateIgnoreChildByName(ctx, objToCreate)
}

// DeleteIgnoreChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteIgnoreChild(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("ignorechilds.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteIgnoreChildByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) Foo(name string) *fooGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["foos.gns.tsm.tanzu.vmware.com"] = name
	return &fooGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetFoo calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetFoo(ctx context.Context, displayName string) (result *GnsFoo, err error) {
	hashedName := helper.GetHashedName("foos.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetFooByName(ctx, hashedName)
}

// AddFoo calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddFoo(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Foo) (result *GnsFoo, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("foos.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateFooByName(ctx, objToCreate)
}

// DeleteFoo calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteFoo(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("foos.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteFooByName(ctx, hashedName)
}

func (group *GnsTsmV1) GetBarChildChildrenMap() map[string]basegnstsmtanzuvmwarecomv1.Child {
	return map[string]basegnstsmtanzuvmwarecomv1.Child{}
}

func (group *GnsTsmV1) GetBarChildChild(grp, kind, name string) basegnstsmtanzuvmwarecomv1.Child {
	return basegnstsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetBarChildByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetBarChildByName(ctx context.Context, hashedName string) (*GnsBarChild, error) {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetBarChildByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basegnstsmtanzuvmwarecomv1.BarChild)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetBarChildByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basegnstsmtanzuvmwarecomv1.BarChild).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetBarChildByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &GnsBarChild{
					client:   group.client,
					BarChild: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &GnsBarChild{
				client:   group.client,
				BarChild: resWrCache.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			BarChilds().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &GnsBarChild{
				client:   group.client,
				BarChild: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetBarChildByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get BarChilds: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetBarChildByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetBarChildByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadBarChildByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) ForceReadBarChildByName(ctx context.Context, hashedName string) (*GnsBarChild, error) {
	log.Debugf("[ForceReadBarChildByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			BarChilds().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadBarChildByName] Failed to Get BarChilds: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get BarChilds: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadBarChildByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadBarChildByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadBarChildByName] Executed Successfully :%s", hashedName)
			return &GnsBarChild{
				client:   group.client,
				BarChild: result,
			}, nil
		}
	}
}

// DeleteBarChildByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteBarChildByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteBarChildByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.BarChild
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			BarChilds().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteBarChildByName] Failed to get BarChilds: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get BarChilds: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteBarChildByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteBarChildByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteBarChildByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			GnsTsmV1().
			BarChilds().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteBarChildByName] failed to delete BarChilds: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete BarChilds: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteBarChildByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteBarChildByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteBarChildByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("barchilds.gns.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteBarChildByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentName, "barchilds.gns.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateBarChildByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateBarChildByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (*GnsBarChild, error) {
	log.Debugf("[CreateBarChildByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.BarChild
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			BarChilds().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateBarChildByName] Failed to create BarChild: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create BarChild: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateBarChildByName] context canceled while creating BarChild: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateBarChildByName] BarChild: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.GnsTsmV1().BarChilds().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateBarChildByName] Unable to Get BarChild %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateBarChildByName] found unexpected error while creating BarChild: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateBarChildByName] BarChild: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("barchilds.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateBarChildByName] BarChild: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashedName, "barchilds.gns.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateBarChildByName] Executed Successfully: %s", objToCreate.GetName())
	return &GnsBarChild{
		client:   group.client,
		BarChild: result,
	}, nil
}

// UpdateBarChildByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateBarChildByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.BarChild) (*GnsBarChild, error) {
	log.Debugf("[UpdateBarChildByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Gns().GetBarChildByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["barchilds.gns.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Name)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Name).IsNil() {
			patchValueName := objToUpdate.Spec.Name
			patchOpName := PatchOp{
				Op:    "replace",
				Path:  "/spec/name",
				Value: patchValueName,
			}
			patch = append(patch, patchOpName)
		}
	} else {
		patchValueName := objToUpdate.Spec.Name
		patchOpName := PatchOp{
			Op:    "replace",
			Path:  "/spec/name",
			Value: patchValueName,
		}
		patch = append(patch, patchOpName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basegnstsmtanzuvmwarecomv1.BarChild
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			BarChilds().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateBarChildByName] Failed to patch BarChild %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger BarChild Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteBarChildByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting BarChild: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("BarChild deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateBarChildByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateBarChildByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger BarChild Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteBarChildByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting BarChild: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("BarChild Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateBarChildByName] Patch BarChild Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("barchilds.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateBarChildByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateBarChildByName] Executed Successfully %s", objToUpdate.GetName())
	return &GnsBarChild{
		client:   group.client,
		BarChild: result,
	}, nil
}

// ListBarChilds returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListBarChilds(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsBarChild, err error) {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsBarChild, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.BarChild)
			result[k] = &GnsBarChild{
				client:   group.client,
				BarChild: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			BarChilds().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsBarChild, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsBarChild{
				client:   group.client,
				BarChild: &item,
			}
		}
	}
	return
}

type GnsBarChild struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.BarChild
}

// Delete removes obj and all it's children from the database.
func (obj *GnsBarChild) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteBarChildByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.BarChild = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsBarChild) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateBarChildByName(ctx, obj.BarChild)
	if err != nil {
		return err
	}
	obj.BarChild = result.BarChild
	return nil
}

func (obj *GnsBarChild) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type barchildGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *barchildGnsTsmV1Chainer) Subscribe() {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewBarChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *barchildGnsTsmV1Chainer) Unsubscribe() {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *barchildGnsTsmV1Chainer) IsSubscribed() bool {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *barchildGnsTsmV1Chainer) addCallback(obj *GnsBarChild) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "barchilds.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *barchildGnsTsmV1Chainer) deleteCallback(obj *GnsBarChild) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "barchilds.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *barchildGnsTsmV1Chainer) RegisterEventHandler(addCB func(obj *GnsBarChild), updateCB func(oldObj, newObj *GnsBarChild), deleteCB func(obj *GnsBarChild)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for GnsBarChild")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsBarChild")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsBarChild, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewBarChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsBarChild{
				client:   c.client,
				BarChild: obj.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "barchilds.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "barchilds.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsBarChild{
				client:   c.client,
				BarChild: oldObj.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}
			newData := &GnsBarChild{
				client:   c.client,
				BarChild: newObj.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &GnsBarChild{
				client:   c.client,
				BarChild: obj.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "barchilds.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "barchilds.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *barchildGnsTsmV1Chainer) RegisterAddCallback(cbfn func(obj *GnsBarChild)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for GnsBarChild")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsBarChild")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsBarChild, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewBarChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsBarChild{
				client:   c.client,
				BarChild: obj.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "barchilds.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "barchilds.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *barchildGnsTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *GnsBarChild)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for GnsBarChild")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsBarChild")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsBarChild, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewBarChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsBarChild{
				client:   c.client,
				BarChild: oldObj.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}
			newData := &GnsBarChild{
				client:   c.client,
				BarChild: newObj.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *barchildGnsTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *GnsBarChild)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for GnsBarChild")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsBarChild")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsBarChild, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewBarChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &GnsBarChild{
				client:   c.client,
				BarChild: obj.(*basegnstsmtanzuvmwarecomv1.BarChild),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "barchilds.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "barchilds.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *GnsTsmV1) GetIgnoreChildChildrenMap() map[string]basegnstsmtanzuvmwarecomv1.Child {
	return map[string]basegnstsmtanzuvmwarecomv1.Child{}
}

func (group *GnsTsmV1) GetIgnoreChildChild(grp, kind, name string) basegnstsmtanzuvmwarecomv1.Child {
	return basegnstsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetIgnoreChildByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetIgnoreChildByName(ctx context.Context, hashedName string) (*GnsIgnoreChild, error) {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetIgnoreChildByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basegnstsmtanzuvmwarecomv1.IgnoreChild)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetIgnoreChildByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basegnstsmtanzuvmwarecomv1.IgnoreChild).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetIgnoreChildByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &GnsIgnoreChild{
					client:      group.client,
					IgnoreChild: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &GnsIgnoreChild{
				client:      group.client,
				IgnoreChild: resWrCache.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			IgnoreChilds().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &GnsIgnoreChild{
				client:      group.client,
				IgnoreChild: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetIgnoreChildByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get IgnoreChilds: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetIgnoreChildByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetIgnoreChildByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadIgnoreChildByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) ForceReadIgnoreChildByName(ctx context.Context, hashedName string) (*GnsIgnoreChild, error) {
	log.Debugf("[ForceReadIgnoreChildByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			IgnoreChilds().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadIgnoreChildByName] Failed to Get IgnoreChilds: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get IgnoreChilds: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadIgnoreChildByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadIgnoreChildByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadIgnoreChildByName] Executed Successfully :%s", hashedName)
			return &GnsIgnoreChild{
				client:      group.client,
				IgnoreChild: result,
			}, nil
		}
	}
}

// DeleteIgnoreChildByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteIgnoreChildByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteIgnoreChildByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.IgnoreChild
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			IgnoreChilds().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteIgnoreChildByName] Failed to get IgnoreChilds: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get IgnoreChilds: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteIgnoreChildByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteIgnoreChildByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteIgnoreChildByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			GnsTsmV1().
			IgnoreChilds().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteIgnoreChildByName] failed to delete IgnoreChilds: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete IgnoreChilds: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteIgnoreChildByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteIgnoreChildByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteIgnoreChildByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("ignorechilds.gns.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteIgnoreChildByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentName, "ignorechilds.gns.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateIgnoreChildByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateIgnoreChildByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.IgnoreChild) (*GnsIgnoreChild, error) {
	log.Debugf("[CreateIgnoreChildByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.IgnoreChild
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			IgnoreChilds().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateIgnoreChildByName] Failed to create IgnoreChild: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create IgnoreChild: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateIgnoreChildByName] context canceled while creating IgnoreChild: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateIgnoreChildByName] IgnoreChild: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.GnsTsmV1().IgnoreChilds().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateIgnoreChildByName] Unable to Get IgnoreChild %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateIgnoreChildByName] found unexpected error while creating IgnoreChild: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateIgnoreChildByName] IgnoreChild: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("ignorechilds.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateIgnoreChildByName] IgnoreChild: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashedName, "ignorechilds.gns.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateIgnoreChildByName] Executed Successfully: %s", objToCreate.GetName())
	return &GnsIgnoreChild{
		client:      group.client,
		IgnoreChild: result,
	}, nil
}

// UpdateIgnoreChildByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateIgnoreChildByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.IgnoreChild) (*GnsIgnoreChild, error) {
	log.Debugf("[UpdateIgnoreChildByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Gns().GetIgnoreChildByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["ignorechilds.gns.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Name)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Name).IsNil() {
			patchValueName := objToUpdate.Spec.Name
			patchOpName := PatchOp{
				Op:    "replace",
				Path:  "/spec/name",
				Value: patchValueName,
			}
			patch = append(patch, patchOpName)
		}
	} else {
		patchValueName := objToUpdate.Spec.Name
		patchOpName := PatchOp{
			Op:    "replace",
			Path:  "/spec/name",
			Value: patchValueName,
		}
		patch = append(patch, patchOpName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basegnstsmtanzuvmwarecomv1.IgnoreChild
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			IgnoreChilds().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateIgnoreChildByName] Failed to patch IgnoreChild %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger IgnoreChild Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteIgnoreChildByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting IgnoreChild: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("IgnoreChild deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateIgnoreChildByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateIgnoreChildByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger IgnoreChild Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteIgnoreChildByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting IgnoreChild: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("IgnoreChild Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateIgnoreChildByName] Patch IgnoreChild Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("ignorechilds.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateIgnoreChildByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateIgnoreChildByName] Executed Successfully %s", objToUpdate.GetName())
	return &GnsIgnoreChild{
		client:      group.client,
		IgnoreChild: result,
	}, nil
}

// ListIgnoreChilds returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListIgnoreChilds(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsIgnoreChild, err error) {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsIgnoreChild, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.IgnoreChild)
			result[k] = &GnsIgnoreChild{
				client:      group.client,
				IgnoreChild: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			IgnoreChilds().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsIgnoreChild, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsIgnoreChild{
				client:      group.client,
				IgnoreChild: &item,
			}
		}
	}
	return
}

type GnsIgnoreChild struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.IgnoreChild
}

// Delete removes obj and all it's children from the database.
func (obj *GnsIgnoreChild) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteIgnoreChildByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.IgnoreChild = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsIgnoreChild) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateIgnoreChildByName(ctx, obj.IgnoreChild)
	if err != nil {
		return err
	}
	obj.IgnoreChild = result.IgnoreChild
	return nil
}

func (obj *GnsIgnoreChild) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type ignorechildGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *ignorechildGnsTsmV1Chainer) Subscribe() {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewIgnoreChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *ignorechildGnsTsmV1Chainer) Unsubscribe() {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *ignorechildGnsTsmV1Chainer) IsSubscribed() bool {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *ignorechildGnsTsmV1Chainer) addCallback(obj *GnsIgnoreChild) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "ignorechilds.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *ignorechildGnsTsmV1Chainer) deleteCallback(obj *GnsIgnoreChild) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "ignorechilds.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *ignorechildGnsTsmV1Chainer) RegisterEventHandler(addCB func(obj *GnsIgnoreChild), updateCB func(oldObj, newObj *GnsIgnoreChild), deleteCB func(obj *GnsIgnoreChild)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for GnsIgnoreChild")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsIgnoreChild")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsIgnoreChild, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewIgnoreChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsIgnoreChild{
				client:      c.client,
				IgnoreChild: obj.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "ignorechilds.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "ignorechilds.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsIgnoreChild{
				client:      c.client,
				IgnoreChild: oldObj.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}
			newData := &GnsIgnoreChild{
				client:      c.client,
				IgnoreChild: newObj.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &GnsIgnoreChild{
				client:      c.client,
				IgnoreChild: obj.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "ignorechilds.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "ignorechilds.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *ignorechildGnsTsmV1Chainer) RegisterAddCallback(cbfn func(obj *GnsIgnoreChild)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for GnsIgnoreChild")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsIgnoreChild")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsIgnoreChild, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewIgnoreChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsIgnoreChild{
				client:      c.client,
				IgnoreChild: obj.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "ignorechilds.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "ignorechilds.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *ignorechildGnsTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *GnsIgnoreChild)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for GnsIgnoreChild")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsIgnoreChild")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsIgnoreChild, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewIgnoreChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsIgnoreChild{
				client:      c.client,
				IgnoreChild: oldObj.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}
			newData := &GnsIgnoreChild{
				client:      c.client,
				IgnoreChild: newObj.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *ignorechildGnsTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *GnsIgnoreChild)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for GnsIgnoreChild")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsIgnoreChild")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsIgnoreChild, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewIgnoreChildInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &GnsIgnoreChild{
				client:      c.client,
				IgnoreChild: obj.(*basegnstsmtanzuvmwarecomv1.IgnoreChild),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "ignorechilds.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "ignorechilds.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *GnsTsmV1) GetDnsChildrenMap() map[string]basegnstsmtanzuvmwarecomv1.Child {
	return map[string]basegnstsmtanzuvmwarecomv1.Child{}
}

func (group *GnsTsmV1) GetDnsChild(grp, kind, name string) basegnstsmtanzuvmwarecomv1.Child {
	return basegnstsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetDnsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetDnsByName(ctx context.Context, hashedName string) (*GnsDns, error) {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetDnsByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basegnstsmtanzuvmwarecomv1.Dns)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetDnsByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basegnstsmtanzuvmwarecomv1.Dns).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetDnsByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &GnsDns{
					client: group.client,
					Dns:    resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &GnsDns{
				client: group.client,
				Dns:    resWrCache.(*basegnstsmtanzuvmwarecomv1.Dns),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Dnses().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &GnsDns{
				client: group.client,
				Dns:    result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetDnsByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Dnses: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetDnsByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetDnsByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadDnsByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) ForceReadDnsByName(ctx context.Context, hashedName string) (*GnsDns, error) {
	log.Debugf("[ForceReadDnsByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Dnses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadDnsByName] Failed to Get Dnses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Dnses: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadDnsByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadDnsByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadDnsByName] Executed Successfully :%s", hashedName)
			return &GnsDns{
				client: group.client,
				Dns:    result,
			}, nil
		}
	}
}

// DeleteDnsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteDnsByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteDnsByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.Dns
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Dnses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteDnsByName] Failed to get Dnses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Dnses: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteDnsByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteDnsByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteDnsByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			GnsTsmV1().
			Dnses().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteDnsByName] failed to delete Dnses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Dnses: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteDnsByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteDnsByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteDnsByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("dnses.gns.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteDnsByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentName, "dnses.gns.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateDnsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateDnsByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (*GnsDns, error) {
	log.Debugf("[CreateDnsByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var (
		retryCount int
		result     *basegnstsmtanzuvmwarecomv1.Dns
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Dnses().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateDnsByName] Failed to create Dns: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Dns: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateDnsByName] context canceled while creating Dns: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateDnsByName] Dns: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.GnsTsmV1().Dnses().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateDnsByName] Unable to Get Dns %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateDnsByName] found unexpected error while creating Dns: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateDnsByName] Dns: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("dnses.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateDnsByName] Dns: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashedName, "dnses.gns.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateDnsByName] Executed Successfully: %s", objToCreate.GetName())
	return &GnsDns{
		client: group.client,
		Dns:    result,
	}, nil
}

// UpdateDnsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateDnsByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Dns) (*GnsDns, error) {
	log.Debugf("[UpdateDnsByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Gns().GetDnsByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["dnses.gns.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basegnstsmtanzuvmwarecomv1.Dns
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			GnsTsmV1().
			Dnses().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateDnsByName] Failed to patch Dns %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Dns Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteDnsByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Dns: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Dns deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateDnsByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateDnsByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Dns Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteDnsByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Dns: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Dns Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateDnsByName] Patch Dns Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("dnses.gns.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateDnsByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateDnsByName] Executed Successfully %s", objToUpdate.GetName())
	return &GnsDns{
		client: group.client,
		Dns:    result,
	}, nil
}

// ListDnses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListDnses(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsDns, err error) {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsDns, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.Dns)
			result[k] = &GnsDns{
				client: group.client,
				Dns:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			Dnses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsDns, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsDns{
				client: group.client,
				Dns:    &item,
			}
		}
	}
	return
}

type GnsDns struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Dns
}

// Delete removes obj and all it's children from the database.
func (obj *GnsDns) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteDnsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Dns = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsDns) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateDnsByName(ctx, obj.Dns)
	if err != nil {
		return err
	}
	obj.Dns = result.Dns
	return nil
}

func (obj *GnsDns) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type dnsGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dnsGnsTsmV1Chainer) Subscribe() {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewDnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *dnsGnsTsmV1Chainer) Unsubscribe() {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dnsGnsTsmV1Chainer) IsSubscribed() bool {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *dnsGnsTsmV1Chainer) addCallback(obj *GnsDns) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "dnses.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *dnsGnsTsmV1Chainer) deleteCallback(obj *GnsDns) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "dnses.gns.tsm.tanzu.vmware.com", obj.Name)
}

func (c *dnsGnsTsmV1Chainer) RegisterEventHandler(addCB func(obj *GnsDns), updateCB func(oldObj, newObj *GnsDns), deleteCB func(obj *GnsDns)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for GnsDns")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsDns")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsDns, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewDnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsDns{
				client: c.client,
				Dns:    obj.(*basegnstsmtanzuvmwarecomv1.Dns),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "dnses.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "dnses.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsDns{
				client: c.client,
				Dns:    oldObj.(*basegnstsmtanzuvmwarecomv1.Dns),
			}
			newData := &GnsDns{
				client: c.client,
				Dns:    newObj.(*basegnstsmtanzuvmwarecomv1.Dns),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &GnsDns{
				client: c.client,
				Dns:    obj.(*basegnstsmtanzuvmwarecomv1.Dns),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "dnses.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "dnses.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *dnsGnsTsmV1Chainer) RegisterAddCallback(cbfn func(obj *GnsDns)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for GnsDns")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsDns")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsDns, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewDnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &GnsDns{
				client: c.client,
				Dns:    obj.(*basegnstsmtanzuvmwarecomv1.Dns),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "dnses.gns.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "dnses.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *dnsGnsTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *GnsDns)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for GnsDns")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsDns")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsDns, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewDnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &GnsDns{
				client: c.client,
				Dns:    oldObj.(*basegnstsmtanzuvmwarecomv1.Dns),
			}
			newData := &GnsDns{
				client: c.client,
				Dns:    newObj.(*basegnstsmtanzuvmwarecomv1.Dns),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *dnsGnsTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *GnsDns)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for GnsDns")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for GnsDns")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for GnsDns, so creating a new one")
		informer = informergnstsmtanzuvmwarecomv1.NewDnsInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &GnsDns{
				client: c.client,
				Dns:    obj.(*basegnstsmtanzuvmwarecomv1.Dns),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "dnses.gns.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "dnses.gns.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *ServicegroupTsmV1) GetSvcGroupChildrenMap() map[string]baseservicegrouptsmtanzuvmwarecomv1.Child {
	return map[string]baseservicegrouptsmtanzuvmwarecomv1.Child{}
}

func (group *ServicegroupTsmV1) GetSvcGroupChild(grp, kind, name string) baseservicegrouptsmtanzuvmwarecomv1.Child {
	return baseservicegrouptsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetSvcGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) GetSvcGroupByName(ctx context.Context, hashedName string) (*ServicegroupSvcGroup, error) {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetSvcGroupByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetSvcGroupByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetSvcGroupByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ServicegroupSvcGroup{
					client:   group.client,
					SvcGroup: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ServicegroupSvcGroup{
				client:   group.client,
				SvcGroup: resWrCache.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ServicegroupSvcGroup{
				client:   group.client,
				SvcGroup: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetSvcGroupByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get SvcGroups: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetSvcGroupByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetSvcGroupByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadSvcGroupByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) ForceReadSvcGroupByName(ctx context.Context, hashedName string) (*ServicegroupSvcGroup, error) {
	log.Debugf("[ForceReadSvcGroupByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadSvcGroupByName] Failed to Get SvcGroups: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get SvcGroups: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadSvcGroupByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadSvcGroupByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadSvcGroupByName] Executed Successfully :%s", hashedName)
			return &ServicegroupSvcGroup{
				client:   group.client,
				SvcGroup: result,
			}, nil
		}
	}
}

// DeleteSvcGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) DeleteSvcGroupByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteSvcGroupByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteSvcGroupByName] Failed to get SvcGroups: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get SvcGroups: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteSvcGroupByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteSvcGroupByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteSvcGroupByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteSvcGroupByName] failed to delete SvcGroups: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete SvcGroups: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteSvcGroupByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteSvcGroupByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteSvcGroupByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("svcgroups.servicegroup.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteSvcGroupByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentName, "svcgroups.servicegroup.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateSvcGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ServicegroupTsmV1) CreateSvcGroupByName(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (*ServicegroupSvcGroup, error) {
	log.Debugf("[CreateSvcGroupByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateSvcGroupByName] Failed to create SvcGroup: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create SvcGroup: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateSvcGroupByName] context canceled while creating SvcGroup: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateSvcGroupByName] SvcGroup: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ServicegroupTsmV1().SvcGroups().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateSvcGroupByName] Unable to Get SvcGroup %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateSvcGroupByName] found unexpected error while creating SvcGroup: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateSvcGroupByName] SvcGroup: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("svcgroups.servicegroup.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateSvcGroupByName] SvcGroup: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashedName, "svcgroups.servicegroup.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateSvcGroupByName] Executed Successfully: %s", objToCreate.GetName())
	return &ServicegroupSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// UpdateSvcGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ServicegroupTsmV1) UpdateSvcGroupByName(ctx context.Context,
	objToUpdate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (*ServicegroupSvcGroup, error) {
	log.Debugf("[UpdateSvcGroupByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Servicegroup().GetSvcGroupByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["svcgroups.servicegroup.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.DisplayName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.DisplayName).IsNil() {
			patchValueDisplayName := objToUpdate.Spec.DisplayName
			patchOpDisplayName := PatchOp{
				Op:    "replace",
				Path:  "/spec/displayName",
				Value: patchValueDisplayName,
			}
			patch = append(patch, patchOpDisplayName)
		}
	} else {
		patchValueDisplayName := objToUpdate.Spec.DisplayName
		patchOpDisplayName := PatchOp{
			Op:    "replace",
			Path:  "/spec/displayName",
			Value: patchValueDisplayName,
		}
		patch = append(patch, patchOpDisplayName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Color)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Color).IsNil() {
			patchValueColor := objToUpdate.Spec.Color
			patchOpColor := PatchOp{
				Op:    "replace",
				Path:  "/spec/color",
				Value: patchValueColor,
			}
			patch = append(patch, patchOpColor)
		}
	} else {
		patchValueColor := objToUpdate.Spec.Color
		patchOpColor := PatchOp{
			Op:    "replace",
			Path:  "/spec/color",
			Value: patchValueColor,
		}
		patch = append(patch, patchOpColor)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateSvcGroupByName] Failed to patch SvcGroup %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger SvcGroup Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteSvcGroupByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting SvcGroup: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("SvcGroup deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateSvcGroupByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateSvcGroupByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger SvcGroup Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteSvcGroupByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting SvcGroup: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("SvcGroup Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateSvcGroupByName] Patch SvcGroup Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("svcgroups.servicegroup.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateSvcGroupByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateSvcGroupByName] Executed Successfully %s", objToUpdate.GetName())
	return &ServicegroupSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// ListSvcGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ServicegroupTsmV1) ListSvcGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*ServicegroupSvcGroup, err error) {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ServicegroupSvcGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup)
			result[k] = &ServicegroupSvcGroup{
				client:   group.client,
				SvcGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ServicegroupTsmV1().
			SvcGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ServicegroupSvcGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ServicegroupSvcGroup{
				client:   group.client,
				SvcGroup: &item,
			}
		}
	}
	return
}

type ServicegroupSvcGroup struct {
	client *Clientset
	*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup
}

// Delete removes obj and all it's children from the database.
func (obj *ServicegroupSvcGroup) Delete(ctx context.Context) error {
	err := obj.client.Servicegroup().DeleteSvcGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SvcGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ServicegroupSvcGroup) Update(ctx context.Context) error {
	result, err := obj.client.Servicegroup().UpdateSvcGroupByName(ctx, obj.SvcGroup)
	if err != nil {
		return err
	}
	obj.SvcGroup = result.SvcGroup
	return nil
}

func (obj *ServicegroupSvcGroup) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type svcgroupServicegroupTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *svcgroupServicegroupTsmV1Chainer) Subscribe() {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *svcgroupServicegroupTsmV1Chainer) Unsubscribe() {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *svcgroupServicegroupTsmV1Chainer) IsSubscribed() bool {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *svcgroupServicegroupTsmV1Chainer) addCallback(obj *ServicegroupSvcGroup) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "svcgroups.servicegroup.tsm.tanzu.vmware.com", obj.Name)
}

func (c *svcgroupServicegroupTsmV1Chainer) deleteCallback(obj *ServicegroupSvcGroup) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "svcgroups.servicegroup.tsm.tanzu.vmware.com", obj.Name)
}

func (c *svcgroupServicegroupTsmV1Chainer) RegisterEventHandler(addCB func(obj *ServicegroupSvcGroup), updateCB func(oldObj, newObj *ServicegroupSvcGroup), deleteCB func(obj *ServicegroupSvcGroup)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ServicegroupSvcGroup")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ServicegroupSvcGroup")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ServicegroupSvcGroup, so creating a new one")
		informer = informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ServicegroupSvcGroup{
				client:   c.client,
				SvcGroup: obj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ServicegroupSvcGroup{
				client:   c.client,
				SvcGroup: oldObj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}
			newData := &ServicegroupSvcGroup{
				client:   c.client,
				SvcGroup: newObj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ServicegroupSvcGroup{
				client:   c.client,
				SvcGroup: obj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *svcgroupServicegroupTsmV1Chainer) RegisterAddCallback(cbfn func(obj *ServicegroupSvcGroup)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for ServicegroupSvcGroup")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ServicegroupSvcGroup")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ServicegroupSvcGroup, so creating a new one")
		informer = informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ServicegroupSvcGroup{
				client:   c.client,
				SvcGroup: obj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *svcgroupServicegroupTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ServicegroupSvcGroup)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for ServicegroupSvcGroup")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ServicegroupSvcGroup")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ServicegroupSvcGroup, so creating a new one")
		informer = informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ServicegroupSvcGroup{
				client:   c.client,
				SvcGroup: oldObj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}
			newData := &ServicegroupSvcGroup{
				client:   c.client,
				SvcGroup: newObj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *svcgroupServicegroupTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *ServicegroupSvcGroup)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for ServicegroupSvcGroup")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ServicegroupSvcGroup")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ServicegroupSvcGroup, so creating a new one")
		informer = informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ServicegroupSvcGroup{
				client:   c.client,
				SvcGroup: obj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "svcgroups.servicegroup.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *ServicegroupTsmV1) GetSvcGroupLinkInfoChildrenMap() map[string]baseservicegrouptsmtanzuvmwarecomv1.Child {
	return map[string]baseservicegrouptsmtanzuvmwarecomv1.Child{}
}

func (group *ServicegroupTsmV1) GetSvcGroupLinkInfoChild(grp, kind, name string) baseservicegrouptsmtanzuvmwarecomv1.Child {
	return baseservicegrouptsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetSvcGroupLinkInfoByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) GetSvcGroupLinkInfoByName(ctx context.Context, hashedName string) (*ServicegroupSvcGroupLinkInfo, error) {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetSvcGroupLinkInfoByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetSvcGroupLinkInfoByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetSvcGroupLinkInfoByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ServicegroupSvcGroupLinkInfo{
					client:           group.client,
					SvcGroupLinkInfo: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ServicegroupSvcGroupLinkInfo{
				client:           group.client,
				SvcGroupLinkInfo: resWrCache.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroupLinkInfos().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ServicegroupSvcGroupLinkInfo{
				client:           group.client,
				SvcGroupLinkInfo: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetSvcGroupLinkInfoByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get SvcGroupLinkInfos: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetSvcGroupLinkInfoByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetSvcGroupLinkInfoByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadSvcGroupLinkInfoByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) ForceReadSvcGroupLinkInfoByName(ctx context.Context, hashedName string) (*ServicegroupSvcGroupLinkInfo, error) {
	log.Debugf("[ForceReadSvcGroupLinkInfoByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroupLinkInfos().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadSvcGroupLinkInfoByName] Failed to Get SvcGroupLinkInfos: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get SvcGroupLinkInfos: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadSvcGroupLinkInfoByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadSvcGroupLinkInfoByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadSvcGroupLinkInfoByName] Executed Successfully :%s", hashedName)
			return &ServicegroupSvcGroupLinkInfo{
				client:           group.client,
				SvcGroupLinkInfo: result,
			}, nil
		}
	}
}

// DeleteSvcGroupLinkInfoByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) DeleteSvcGroupLinkInfoByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteSvcGroupLinkInfoByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroupLinkInfos().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteSvcGroupLinkInfoByName] Failed to get SvcGroupLinkInfos: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get SvcGroupLinkInfos: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteSvcGroupLinkInfoByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteSvcGroupLinkInfoByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteSvcGroupLinkInfoByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroupLinkInfos().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteSvcGroupLinkInfoByName] failed to delete SvcGroupLinkInfos: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete SvcGroupLinkInfos: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteSvcGroupLinkInfoByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteSvcGroupLinkInfoByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteSvcGroupLinkInfoByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteSvcGroupLinkInfoByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentName, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateSvcGroupLinkInfoByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ServicegroupTsmV1) CreateSvcGroupLinkInfoByName(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo) (*ServicegroupSvcGroupLinkInfo, error) {
	log.Debugf("[CreateSvcGroupLinkInfoByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroupLinkInfos().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateSvcGroupLinkInfoByName] Failed to create SvcGroupLinkInfo: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create SvcGroupLinkInfo: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateSvcGroupLinkInfoByName] context canceled while creating SvcGroupLinkInfo: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateSvcGroupLinkInfoByName] SvcGroupLinkInfo: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ServicegroupTsmV1().SvcGroupLinkInfos().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateSvcGroupLinkInfoByName] Unable to Get SvcGroupLinkInfo %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateSvcGroupLinkInfoByName] found unexpected error while creating SvcGroupLinkInfo: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateSvcGroupLinkInfoByName] SvcGroupLinkInfo: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateSvcGroupLinkInfoByName] SvcGroupLinkInfo: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashedName, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateSvcGroupLinkInfoByName] Executed Successfully: %s", objToCreate.GetName())
	return &ServicegroupSvcGroupLinkInfo{
		client:           group.client,
		SvcGroupLinkInfo: result,
	}, nil
}

// UpdateSvcGroupLinkInfoByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ServicegroupTsmV1) UpdateSvcGroupLinkInfoByName(ctx context.Context,
	objToUpdate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo) (*ServicegroupSvcGroupLinkInfo, error) {
	log.Debugf("[UpdateSvcGroupLinkInfoByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Servicegroup().GetSvcGroupLinkInfoByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.ClusterName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ClusterName).IsNil() {
			patchValueClusterName := objToUpdate.Spec.ClusterName
			patchOpClusterName := PatchOp{
				Op:    "replace",
				Path:  "/spec/clusterName",
				Value: patchValueClusterName,
			}
			patch = append(patch, patchOpClusterName)
		}
	} else {
		patchValueClusterName := objToUpdate.Spec.ClusterName
		patchOpClusterName := PatchOp{
			Op:    "replace",
			Path:  "/spec/clusterName",
			Value: patchValueClusterName,
		}
		patch = append(patch, patchOpClusterName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.DomainName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.DomainName).IsNil() {
			patchValueDomainName := objToUpdate.Spec.DomainName
			patchOpDomainName := PatchOp{
				Op:    "replace",
				Path:  "/spec/domainName",
				Value: patchValueDomainName,
			}
			patch = append(patch, patchOpDomainName)
		}
	} else {
		patchValueDomainName := objToUpdate.Spec.DomainName
		patchOpDomainName := PatchOp{
			Op:    "replace",
			Path:  "/spec/domainName",
			Value: patchValueDomainName,
		}
		patch = append(patch, patchOpDomainName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ServiceName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ServiceName).IsNil() {
			patchValueServiceName := objToUpdate.Spec.ServiceName
			patchOpServiceName := PatchOp{
				Op:    "replace",
				Path:  "/spec/serviceName",
				Value: patchValueServiceName,
			}
			patch = append(patch, patchOpServiceName)
		}
	} else {
		patchValueServiceName := objToUpdate.Spec.ServiceName
		patchOpServiceName := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceName",
			Value: patchValueServiceName,
		}
		patch = append(patch, patchOpServiceName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ServiceType)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ServiceType).IsNil() {
			patchValueServiceType := objToUpdate.Spec.ServiceType
			patchOpServiceType := PatchOp{
				Op:    "replace",
				Path:  "/spec/serviceType",
				Value: patchValueServiceType,
			}
			patch = append(patch, patchOpServiceType)
		}
	} else {
		patchValueServiceType := objToUpdate.Spec.ServiceType
		patchOpServiceType := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceType",
			Value: patchValueServiceType,
		}
		patch = append(patch, patchOpServiceType)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroupLinkInfos().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateSvcGroupLinkInfoByName] Failed to patch SvcGroupLinkInfo %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger SvcGroupLinkInfo Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteSvcGroupLinkInfoByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting SvcGroupLinkInfo: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("SvcGroupLinkInfo deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateSvcGroupLinkInfoByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateSvcGroupLinkInfoByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger SvcGroupLinkInfo Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteSvcGroupLinkInfoByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting SvcGroupLinkInfo: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("SvcGroupLinkInfo Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateSvcGroupLinkInfoByName] Patch SvcGroupLinkInfo Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateSvcGroupLinkInfoByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateSvcGroupLinkInfoByName] Executed Successfully %s", objToUpdate.GetName())
	return &ServicegroupSvcGroupLinkInfo{
		client:           group.client,
		SvcGroupLinkInfo: result,
	}, nil
}

// ListSvcGroupLinkInfos returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ServicegroupTsmV1) ListSvcGroupLinkInfos(ctx context.Context,
	opts metav1.ListOptions) (result []*ServicegroupSvcGroupLinkInfo, err error) {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ServicegroupSvcGroupLinkInfo, len(items))
		for k, v := range items {
			item, _ := v.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo)
			result[k] = &ServicegroupSvcGroupLinkInfo{
				client:           group.client,
				SvcGroupLinkInfo: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ServicegroupTsmV1().
			SvcGroupLinkInfos().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ServicegroupSvcGroupLinkInfo, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ServicegroupSvcGroupLinkInfo{
				client:           group.client,
				SvcGroupLinkInfo: &item,
			}
		}
	}
	return
}

type ServicegroupSvcGroupLinkInfo struct {
	client *Clientset
	*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo
}

// Delete removes obj and all it's children from the database.
func (obj *ServicegroupSvcGroupLinkInfo) Delete(ctx context.Context) error {
	err := obj.client.Servicegroup().DeleteSvcGroupLinkInfoByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SvcGroupLinkInfo = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ServicegroupSvcGroupLinkInfo) Update(ctx context.Context) error {
	result, err := obj.client.Servicegroup().UpdateSvcGroupLinkInfoByName(ctx, obj.SvcGroupLinkInfo)
	if err != nil {
		return err
	}
	obj.SvcGroupLinkInfo = result.SvcGroupLinkInfo
	return nil
}

func (obj *ServicegroupSvcGroupLinkInfo) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type svcgrouplinkinfoServicegroupTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) Subscribe() {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupLinkInfoInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) Unsubscribe() {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) IsSubscribed() bool {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) addCallback(obj *ServicegroupSvcGroupLinkInfo) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", obj.Name)
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) deleteCallback(obj *ServicegroupSvcGroupLinkInfo) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", obj.Name)
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) RegisterEventHandler(addCB func(obj *ServicegroupSvcGroupLinkInfo), updateCB func(oldObj, newObj *ServicegroupSvcGroupLinkInfo), deleteCB func(obj *ServicegroupSvcGroupLinkInfo)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ServicegroupSvcGroupLinkInfo")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ServicegroupSvcGroupLinkInfo")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ServicegroupSvcGroupLinkInfo, so creating a new one")
		informer = informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupLinkInfoInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ServicegroupSvcGroupLinkInfo{
				client:           c.client,
				SvcGroupLinkInfo: obj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ServicegroupSvcGroupLinkInfo{
				client:           c.client,
				SvcGroupLinkInfo: oldObj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}
			newData := &ServicegroupSvcGroupLinkInfo{
				client:           c.client,
				SvcGroupLinkInfo: newObj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ServicegroupSvcGroupLinkInfo{
				client:           c.client,
				SvcGroupLinkInfo: obj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) RegisterAddCallback(cbfn func(obj *ServicegroupSvcGroupLinkInfo)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for ServicegroupSvcGroupLinkInfo")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ServicegroupSvcGroupLinkInfo")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ServicegroupSvcGroupLinkInfo, so creating a new one")
		informer = informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupLinkInfoInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ServicegroupSvcGroupLinkInfo{
				client:           c.client,
				SvcGroupLinkInfo: obj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ServicegroupSvcGroupLinkInfo)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for ServicegroupSvcGroupLinkInfo")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ServicegroupSvcGroupLinkInfo")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ServicegroupSvcGroupLinkInfo, so creating a new one")
		informer = informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupLinkInfoInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ServicegroupSvcGroupLinkInfo{
				client:           c.client,
				SvcGroupLinkInfo: oldObj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}
			newData := &ServicegroupSvcGroupLinkInfo{
				client:           c.client,
				SvcGroupLinkInfo: newObj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *ServicegroupSvcGroupLinkInfo)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for ServicegroupSvcGroupLinkInfo")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ServicegroupSvcGroupLinkInfo")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ServicegroupSvcGroupLinkInfo, so creating a new one")
		informer = informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupLinkInfoInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ServicegroupSvcGroupLinkInfo{
				client:           c.client,
				SvcGroupLinkInfo: obj.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *PolicypkgTsmV1) GetAccessControlPolicyChildrenMap() map[string]basepolicypkgtsmtanzuvmwarecomv1.Child {
	return map[string]basepolicypkgtsmtanzuvmwarecomv1.Child{}
}

func (group *PolicypkgTsmV1) GetAccessControlPolicyChild(grp, kind, name string) basepolicypkgtsmtanzuvmwarecomv1.Child {
	return basepolicypkgtsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetAccessControlPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) GetAccessControlPolicyByName(ctx context.Context, hashedName string) (*PolicypkgAccessControlPolicy, error) {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetAccessControlPolicyByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetAccessControlPolicyByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetAccessControlPolicyByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &PolicypkgAccessControlPolicy{
					client:              group.client,
					AccessControlPolicy: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &PolicypkgAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: resWrCache.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &PolicypkgAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetAccessControlPolicyByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get AccessControlPolicies: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetAccessControlPolicyByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetAccessControlPolicyByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadAccessControlPolicyByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) ForceReadAccessControlPolicyByName(ctx context.Context, hashedName string) (*PolicypkgAccessControlPolicy, error) {
	log.Debugf("[ForceReadAccessControlPolicyByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadAccessControlPolicyByName] Failed to Get AccessControlPolicies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get AccessControlPolicies: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadAccessControlPolicyByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadAccessControlPolicyByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadAccessControlPolicyByName] Executed Successfully :%s", hashedName)
			return &PolicypkgAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: result,
			}, nil
		}
	}
}

// DeleteAccessControlPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) DeleteAccessControlPolicyByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteAccessControlPolicyByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteAccessControlPolicyByName] Failed to get AccessControlPolicies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get AccessControlPolicies: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteAccessControlPolicyByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteAccessControlPolicyByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteAccessControlPolicyByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", hashedName, "acpconfigs.policypkg.tsm.tanzu.vmware.com") {
		err := group.client.Policypkg().DeleteACPConfigByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", hashedName, "acpconfigs.policypkg.tsm.tanzu.vmware.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			PolicypkgTsmV1().
			AccessControlPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteAccessControlPolicyByName] failed to delete AccessControlPolicies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete AccessControlPolicies: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteAccessControlPolicyByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteAccessControlPolicyByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteAccessControlPolicyByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteAccessControlPolicyByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentName, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateAccessControlPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicypkgTsmV1) CreateAccessControlPolicyByName(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy) (*PolicypkgAccessControlPolicy, error) {
	log.Debugf("[CreateAccessControlPolicyByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PolicyConfigsGvk = nil

	var (
		retryCount int
		result     *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			AccessControlPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateAccessControlPolicyByName] Failed to create AccessControlPolicy: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create AccessControlPolicy: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateAccessControlPolicyByName] context canceled while creating AccessControlPolicy: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateAccessControlPolicyByName] AccessControlPolicy: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.PolicypkgTsmV1().AccessControlPolicies().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateAccessControlPolicyByName] Unable to Get AccessControlPolicy %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateAccessControlPolicyByName] found unexpected error while creating AccessControlPolicy: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateAccessControlPolicyByName] AccessControlPolicy: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateAccessControlPolicyByName] AccessControlPolicy: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashedName, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateAccessControlPolicyByName] Executed Successfully: %s", objToCreate.GetName())
	return &PolicypkgAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// UpdateAccessControlPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicypkgTsmV1) UpdateAccessControlPolicyByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy) (*PolicypkgAccessControlPolicy, error) {
	log.Debugf("[UpdateAccessControlPolicyByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Policypkg().GetAccessControlPolicyByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			AccessControlPolicies().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateAccessControlPolicyByName] Failed to patch AccessControlPolicy %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger AccessControlPolicy Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteAccessControlPolicyByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting AccessControlPolicy: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("AccessControlPolicy deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateAccessControlPolicyByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateAccessControlPolicyByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger AccessControlPolicy Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteAccessControlPolicyByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting AccessControlPolicy: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("AccessControlPolicy Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateAccessControlPolicyByName] Patch AccessControlPolicy Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateAccessControlPolicyByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateAccessControlPolicyByName] Executed Successfully %s", objToUpdate.GetName())
	return &PolicypkgAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// ListAccessControlPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *PolicypkgTsmV1) ListAccessControlPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicypkgAccessControlPolicy, err error) {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*PolicypkgAccessControlPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy)
			result[k] = &PolicypkgAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.PolicypkgTsmV1().
			AccessControlPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*PolicypkgAccessControlPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &PolicypkgAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: &item,
			}
		}
	}
	return
}

type PolicypkgAccessControlPolicy struct {
	client *Clientset
	*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *PolicypkgAccessControlPolicy) Delete(ctx context.Context) error {
	err := obj.client.Policypkg().DeleteAccessControlPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AccessControlPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicypkgAccessControlPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Policypkg().UpdateAccessControlPolicyByName(ctx, obj.AccessControlPolicy)
	if err != nil {
		return err
	}
	obj.AccessControlPolicy = result.AccessControlPolicy
	return nil
}

func (obj *PolicypkgAccessControlPolicy) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type PolicypkgAccessControlPolicyPolicyConfigs struct {
	client        *Clientset
	PolicyConfigs []basepolicypkgtsmtanzuvmwarecomv1.Child
}

func (n *PolicypkgAccessControlPolicyPolicyConfigs) Next(ctx context.Context) (*PolicypkgACPConfig, error) {
	for index, child := range n.PolicyConfigs {
		obj, err := n.client.Policypkg().GetACPConfigByName(ctx, child.Name)
		if err == nil {
			if index == len(n.PolicyConfigs)-1 {
				n.PolicyConfigs = nil
			} else {
				n.PolicyConfigs = n.PolicyConfigs[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllPolicyConfigsIter returns an iterator for all children of given type
func (obj *PolicypkgAccessControlPolicy) GetAllPolicyConfigsIter(ctx context.Context) (
	result PolicypkgAccessControlPolicyPolicyConfigs) {
	result.client = obj.client
	for _, v := range GetChildren("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com") {
		result.PolicyConfigs = append(result.PolicyConfigs, basepolicypkgtsmtanzuvmwarecomv1.Child{
			Group: "policypkg.tsm.tanzu.vmware.com",
			Kind:  "ACPConfig",
			Name:  v,
		})
	}
	return
}

// GetAllPolicyConfigs returns all children of a given type
func (obj *PolicypkgAccessControlPolicy) GetAllPolicyConfigs(ctx context.Context) (
	result []*PolicypkgACPConfig, err error) {
	for _, v := range GetChildren("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com") {
		l, err := obj.client.Policypkg().GetACPConfigByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPolicyConfigs returns child which has given displayName
func (obj *PolicypkgAccessControlPolicy) GetPolicyConfigs(ctx context.Context,
	displayName string) (result *PolicypkgACPConfig, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", parentLabels, displayName)
	if IsChildExists("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Policypkg.AccessControlPolicy", "PolicyConfigs", displayName)
	}

	result, err = obj.client.Policypkg().GetACPConfigByName(ctx, childHashName)
	return
}

// AddPolicyConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *PolicypkgAccessControlPolicy) AddPolicyConfigs(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig) (result *PolicypkgACPConfig, err error) {
	log.Debugf("[AddPolicyConfigs] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Policypkg().CreateACPConfigByName(ctx, objToCreate)
	log.Debugf("[AddPolicyConfigs] ACPConfig created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Policypkg().GetAccessControlPolicyByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AccessControlPolicy = updatedObj.AccessControlPolicy
	}
	log.Debugf("[AddPolicyConfigs] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeletePolicyConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *PolicypkgAccessControlPolicy) DeletePolicyConfigs(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeletePolicyConfigs] Received for ACPConfig object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", parentLabels, displayName)
	if IsChildExists("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Policypkg.AccessControlPolicy", "PolicyConfigs", displayName)
	}

	err = obj.client.Policypkg().DeleteACPConfigByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeletePolicyConfigs] ACPConfig object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Policypkg().GetAccessControlPolicyByName(ctx, obj.GetName())
	if err == nil {
		obj.AccessControlPolicy = updatedObj.AccessControlPolicy
	}
	return
}

type accesscontrolpolicyPolicypkgTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) Subscribe() {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) Unsubscribe() {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) IsSubscribed() bool {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) addCallback(obj *PolicypkgAccessControlPolicy) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Name)
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) deleteCallback(obj *PolicypkgAccessControlPolicy) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["gnses.gns.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parentHashName, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Name)
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) RegisterEventHandler(addCB func(obj *PolicypkgAccessControlPolicy), updateCB func(oldObj, newObj *PolicypkgAccessControlPolicy), deleteCB func(obj *PolicypkgAccessControlPolicy)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for PolicypkgAccessControlPolicy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgAccessControlPolicy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgAccessControlPolicy, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &PolicypkgAccessControlPolicy{
				client:              c.client,
				AccessControlPolicy: obj.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &PolicypkgAccessControlPolicy{
				client:              c.client,
				AccessControlPolicy: oldObj.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}
			newData := &PolicypkgAccessControlPolicy{
				client:              c.client,
				AccessControlPolicy: newObj.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &PolicypkgAccessControlPolicy{
				client:              c.client,
				AccessControlPolicy: obj.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) RegisterAddCallback(cbfn func(obj *PolicypkgAccessControlPolicy)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for PolicypkgAccessControlPolicy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgAccessControlPolicy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgAccessControlPolicy, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &PolicypkgAccessControlPolicy{
				client:              c.client,
				AccessControlPolicy: obj.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *PolicypkgAccessControlPolicy)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for PolicypkgAccessControlPolicy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgAccessControlPolicy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgAccessControlPolicy, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &PolicypkgAccessControlPolicy{
				client:              c.client,
				AccessControlPolicy: oldObj.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}
			newData := &PolicypkgAccessControlPolicy{
				client:              c.client,
				AccessControlPolicy: newObj.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *PolicypkgAccessControlPolicy)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for PolicypkgAccessControlPolicy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgAccessControlPolicy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgAccessControlPolicy, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &PolicypkgAccessControlPolicy{
				client:              c.client,
				AccessControlPolicy: obj.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy),
			}

			var parent *GnsGns
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["gnses.gns.tsm.tanzu.vmware.com"])
				parent, err = c.client.Gns().ForceReadGnsByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("gnses.gns.tsm.tanzu.vmware.com", parent.Name, "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) PolicyConfigs(name string) *acpconfigPolicypkgTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["acpconfigs.policypkg.tsm.tanzu.vmware.com"] = name
	return &acpconfigPolicypkgTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPolicyConfigs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) GetPolicyConfigs(ctx context.Context, displayName string) (result *PolicypkgACPConfig, err error) {
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Policypkg().GetACPConfigByName(ctx, hashedName)
}

// AddPolicyConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) AddPolicyConfigs(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig) (result *PolicypkgACPConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Policypkg().CreateACPConfigByName(ctx, objToCreate)
}

// DeletePolicyConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) DeletePolicyConfigs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Policypkg().DeleteACPConfigByName(ctx, hashedName)
}

func (group *PolicypkgTsmV1) GetACPConfigChildrenMap() map[string]basepolicypkgtsmtanzuvmwarecomv1.Child {
	return map[string]basepolicypkgtsmtanzuvmwarecomv1.Child{}
}

func (group *PolicypkgTsmV1) GetACPConfigChild(grp, kind, name string) basepolicypkgtsmtanzuvmwarecomv1.Child {
	return basepolicypkgtsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetACPConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) GetACPConfigByName(ctx context.Context, hashedName string) (*PolicypkgACPConfig, error) {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetACPConfigByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetACPConfigByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetACPConfigByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &PolicypkgACPConfig{
					client:    group.client,
					ACPConfig: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &PolicypkgACPConfig{
				client:    group.client,
				ACPConfig: resWrCache.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &PolicypkgACPConfig{
				client:    group.client,
				ACPConfig: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetACPConfigByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get ACPConfigs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetACPConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetACPConfigByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadACPConfigByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) ForceReadACPConfigByName(ctx context.Context, hashedName string) (*PolicypkgACPConfig, error) {
	log.Debugf("[ForceReadACPConfigByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadACPConfigByName] Failed to Get ACPConfigs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get ACPConfigs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadACPConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadACPConfigByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadACPConfigByName] Executed Successfully :%s", hashedName)
			return &PolicypkgACPConfig{
				client:    group.client,
				ACPConfig: result,
			}, nil
		}
	}
}

// DeleteACPConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) DeleteACPConfigByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteACPConfigByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteACPConfigByName] Failed to get ACPConfigs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get ACPConfigs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteACPConfigByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteACPConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteACPConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			PolicypkgTsmV1().
			ACPConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteACPConfigByName] failed to delete ACPConfigs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete ACPConfigs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteACPConfigByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteACPConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteACPConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("acpconfigs.policypkg.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteACPConfigByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parentName, "acpconfigs.policypkg.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateACPConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicypkgTsmV1) CreateACPConfigByName(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig) (*PolicypkgACPConfig, error) {
	log.Debugf("[CreateACPConfigByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DestSvcGroupsGvk = nil
	objToCreate.Spec.SourceSvcGroupsGvk = nil

	var (
		retryCount int
		result     *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			ACPConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateACPConfigByName] Failed to create ACPConfig: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create ACPConfig: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateACPConfigByName] context canceled while creating ACPConfig: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateACPConfigByName] ACPConfig: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.PolicypkgTsmV1().ACPConfigs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateACPConfigByName] Unable to Get ACPConfig %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateACPConfigByName] found unexpected error while creating ACPConfig: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateACPConfigByName] ACPConfig: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("acpconfigs.policypkg.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateACPConfigByName] ACPConfig: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parentHashedName, "acpconfigs.policypkg.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateACPConfigByName] Executed Successfully: %s", objToCreate.GetName())
	return &PolicypkgACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// SetACPConfigStatusByName sets user defined status
func (group *PolicypkgTsmV1) SetACPConfigStatusByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig, status *basepolicypkgtsmtanzuvmwarecomv1.ACPStatus) (*PolicypkgACPConfig, error) {
	log.Debugf("[SetACPConfigStatusByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "policypkg.tsm.tanzu.vmware.com",
		Version:  "v1",
		Resource: strings.ToLower("ACPConfigs"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := basepolicypkgtsmtanzuvmwarecomv1.ACPConfig{}
	obj.Kind = strings.ToLower("ACPConfigs")
	obj.APIVersion = "policypkg.tsm.tanzu.vmware.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.Status = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.dynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			log.Debugf("[SetACPConfigStatusByName] Updating status for ACPConfig node %s successful", hashedName)
			break
		}

		log.Errorf("[SetACPConfigStatusByName] Updating status for ACPConfig node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadACPConfigByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			log.Fatalf("[SetACPConfigStatusByName] Max retry exceeded for updating status for ACPConfig node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("acpconfigs.policypkg.tsm.tanzu.vmware.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig
			if inWrCache {
				objectToWrite = resWrCache.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig)
				objectToWrite.Status.Status = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.Status = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &PolicypkgACPConfig{
		client:    group.client,
		ACPConfig: objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateACPConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicypkgTsmV1) UpdateACPConfigByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig) (*PolicypkgACPConfig, error) {
	log.Debugf("[UpdateACPConfigByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Policypkg().GetACPConfigByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["acpconfigs.policypkg.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.DisplayName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.DisplayName).IsNil() {
			patchValueDisplayName := objToUpdate.Spec.DisplayName
			patchOpDisplayName := PatchOp{
				Op:    "replace",
				Path:  "/spec/displayName",
				Value: patchValueDisplayName,
			}
			patch = append(patch, patchOpDisplayName)
		}
	} else {
		patchValueDisplayName := objToUpdate.Spec.DisplayName
		patchOpDisplayName := PatchOp{
			Op:    "replace",
			Path:  "/spec/displayName",
			Value: patchValueDisplayName,
		}
		patch = append(patch, patchOpDisplayName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Gns)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Gns).IsNil() {
			patchValueGns := objToUpdate.Spec.Gns
			patchOpGns := PatchOp{
				Op:    "replace",
				Path:  "/spec/gns",
				Value: patchValueGns,
			}
			patch = append(patch, patchOpGns)
		}
	} else {
		patchValueGns := objToUpdate.Spec.Gns
		patchOpGns := PatchOp{
			Op:    "replace",
			Path:  "/spec/gns",
			Value: patchValueGns,
		}
		patch = append(patch, patchOpGns)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Tags)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Tags).IsNil() {
			patchValueTags := objToUpdate.Spec.Tags
			patchOpTags := PatchOp{
				Op:    "replace",
				Path:  "/spec/tags",
				Value: patchValueTags,
			}
			patch = append(patch, patchOpTags)
		}
	} else {
		patchValueTags := objToUpdate.Spec.Tags
		patchOpTags := PatchOp{
			Op:    "replace",
			Path:  "/spec/tags",
			Value: patchValueTags,
		}
		patch = append(patch, patchOpTags)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.ProjectId)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ProjectId).IsNil() {
			patchValueProjectId := objToUpdate.Spec.ProjectId
			patchOpProjectId := PatchOp{
				Op:    "replace",
				Path:  "/spec/projectId",
				Value: patchValueProjectId,
			}
			patch = append(patch, patchOpProjectId)
		}
	} else {
		patchValueProjectId := objToUpdate.Spec.ProjectId
		patchOpProjectId := PatchOp{
			Op:    "replace",
			Path:  "/spec/projectId",
			Value: patchValueProjectId,
		}
		patch = append(patch, patchOpProjectId)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Conditions)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Conditions).IsNil() {
			patchValueConditions := objToUpdate.Spec.Conditions
			patchOpConditions := PatchOp{
				Op:    "replace",
				Path:  "/spec/conditions",
				Value: patchValueConditions,
			}
			patch = append(patch, patchOpConditions)
		}
	} else {
		patchValueConditions := objToUpdate.Spec.Conditions
		patchOpConditions := PatchOp{
			Op:    "replace",
			Path:  "/spec/conditions",
			Value: patchValueConditions,
		}
		patch = append(patch, patchOpConditions)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			ACPConfigs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateACPConfigByName] Failed to patch ACPConfig %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger ACPConfig Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteACPConfigByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting ACPConfig: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("ACPConfig deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateACPConfigByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateACPConfigByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger ACPConfig Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteACPConfigByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting ACPConfig: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("ACPConfig Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateACPConfigByName] Patch ACPConfig Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("acpconfigs.policypkg.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateACPConfigByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateACPConfigByName] Executed Successfully %s", objToUpdate.GetName())
	return &PolicypkgACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// ListACPConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *PolicypkgTsmV1) ListACPConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicypkgACPConfig, err error) {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*PolicypkgACPConfig, len(items))
		for k, v := range items {
			item, _ := v.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig)
			result[k] = &PolicypkgACPConfig{
				client:    group.client,
				ACPConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.PolicypkgTsmV1().
			ACPConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*PolicypkgACPConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &PolicypkgACPConfig{
				client:    group.client,
				ACPConfig: &item,
			}
		}
	}
	return
}

type PolicypkgACPConfig struct {
	client *Clientset
	*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig
}

// Delete removes obj and all it's children from the database.
func (obj *PolicypkgACPConfig) Delete(ctx context.Context) error {
	err := obj.client.Policypkg().DeleteACPConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ACPConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicypkgACPConfig) Update(ctx context.Context) error {
	result, err := obj.client.Policypkg().UpdateACPConfigByName(ctx, obj.ACPConfig)
	if err != nil {
		return err
	}
	obj.ACPConfig = result.ACPConfig
	return nil
}

// SetStatus sets user defined status
func (obj *PolicypkgACPConfig) SetStatus(ctx context.Context, status *basepolicypkgtsmtanzuvmwarecomv1.ACPStatus) error {
	result, err := obj.client.Policypkg().SetACPConfigStatusByName(ctx, obj.ACPConfig, status)
	if err != nil {
		return err
	}
	obj.ACPConfig = result.ACPConfig
	return nil
}

// GetStatus to get user defined status
func (obj *PolicypkgACPConfig) GetStatus(ctx context.Context) (*basepolicypkgtsmtanzuvmwarecomv1.ACPStatus, error) {
	getObj, err := obj.client.Policypkg().GetACPConfigByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *PolicypkgACPConfig) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Policypkg().SetACPConfigStatusByName(ctx, obj.ACPConfig, &basepolicypkgtsmtanzuvmwarecomv1.ACPStatus{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result.ACPConfig
	return nil
}

func (obj *PolicypkgACPConfig) GetParent(ctx context.Context) (result *PolicypkgAccessControlPolicy, err error) {
	hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"])
	return obj.client.Policypkg().GetAccessControlPolicyByName(ctx, hashedName)
}

// GetAllDestSvcGroups returns all links of given type
func (obj *PolicypkgACPConfig) GetAllDestSvcGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	result = make([]*ServicegroupSvcGroup, 0, len(obj.Spec.DestSvcGroupsGvk))
	for _, v := range obj.Spec.DestSvcGroupsGvk {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDestSvcGroups returns link which has given displayName
func (obj *PolicypkgACPConfig) GetDestSvcGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {
	l, ok := obj.Spec.DestSvcGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Policypkg.ACPConfig", "DestSvcGroups", displayName)
	}
	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkDestSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *PolicypkgACPConfig) LinkDestSvcGroups(ctx context.Context,
	linkToAdd *ServicegroupSvcGroup) error {

	payload := "{\"spec\": {\"destSvcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"servicegroup.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.PolicypkgTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ACPConfig = result
	return nil
}

// UnlinkDestSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *PolicypkgACPConfig) UnlinkDestSvcGroups(ctx context.Context,
	linkToRemove *ServicegroupSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/destSvcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.PolicypkgTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil

}

// GetAllSourceSvcGroups returns all links of given type
func (obj *PolicypkgACPConfig) GetAllSourceSvcGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	result = make([]*ServicegroupSvcGroup, 0, len(obj.Spec.SourceSvcGroupsGvk))
	for _, v := range obj.Spec.SourceSvcGroupsGvk {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSourceSvcGroups returns link which has given displayName
func (obj *PolicypkgACPConfig) GetSourceSvcGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {
	l, ok := obj.Spec.SourceSvcGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Policypkg.ACPConfig", "SourceSvcGroups", displayName)
	}
	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkSourceSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *PolicypkgACPConfig) LinkSourceSvcGroups(ctx context.Context,
	linkToAdd *ServicegroupSvcGroup) error {

	payload := "{\"spec\": {\"sourceSvcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"servicegroup.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.PolicypkgTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ACPConfig = result
	return nil
}

// UnlinkSourceSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *PolicypkgACPConfig) UnlinkSourceSvcGroups(ctx context.Context,
	linkToRemove *ServicegroupSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sourceSvcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.PolicypkgTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil

}

type acpconfigPolicypkgTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *acpconfigPolicypkgTsmV1Chainer) Subscribe() {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewACPConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *acpconfigPolicypkgTsmV1Chainer) Unsubscribe() {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *acpconfigPolicypkgTsmV1Chainer) IsSubscribed() bool {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *acpconfigPolicypkgTsmV1Chainer) addCallback(obj *PolicypkgACPConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parentHashName, "acpconfigs.policypkg.tsm.tanzu.vmware.com", obj.Name)
}

func (c *acpconfigPolicypkgTsmV1Chainer) deleteCallback(obj *PolicypkgACPConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parentHashName, "acpconfigs.policypkg.tsm.tanzu.vmware.com", obj.Name)
}

func (c *acpconfigPolicypkgTsmV1Chainer) RegisterEventHandler(addCB func(obj *PolicypkgACPConfig), updateCB func(oldObj, newObj *PolicypkgACPConfig), deleteCB func(obj *PolicypkgACPConfig)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for PolicypkgACPConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgACPConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgACPConfig, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewACPConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &PolicypkgACPConfig{
				client:    c.client,
				ACPConfig: obj.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}

			var parent *PolicypkgAccessControlPolicy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"])
				parent, err = c.client.Policypkg().ForceReadAccessControlPolicyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parent.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parent.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &PolicypkgACPConfig{
				client:    c.client,
				ACPConfig: oldObj.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}
			newData := &PolicypkgACPConfig{
				client:    c.client,
				ACPConfig: newObj.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &PolicypkgACPConfig{
				client:    c.client,
				ACPConfig: obj.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}

			var parent *PolicypkgAccessControlPolicy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"])
				parent, err = c.client.Policypkg().ForceReadAccessControlPolicyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parent.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parent.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *acpconfigPolicypkgTsmV1Chainer) RegisterAddCallback(cbfn func(obj *PolicypkgACPConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for PolicypkgACPConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgACPConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgACPConfig, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewACPConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &PolicypkgACPConfig{
				client:    c.client,
				ACPConfig: obj.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}

			var parent *PolicypkgAccessControlPolicy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"])
				parent, err = c.client.Policypkg().ForceReadAccessControlPolicyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parent.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parent.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *acpconfigPolicypkgTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *PolicypkgACPConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for PolicypkgACPConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgACPConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgACPConfig, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewACPConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &PolicypkgACPConfig{
				client:    c.client,
				ACPConfig: oldObj.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}
			newData := &PolicypkgACPConfig{
				client:    c.client,
				ACPConfig: newObj.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *acpconfigPolicypkgTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *PolicypkgACPConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for PolicypkgACPConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgACPConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgACPConfig, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewACPConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &PolicypkgACPConfig{
				client:    c.client,
				ACPConfig: obj.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig),
			}

			var parent *PolicypkgAccessControlPolicy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"])
				parent, err = c.client.Policypkg().ForceReadAccessControlPolicyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parent.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parent.Name, "acpconfigs.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

// ClearStatus to clear user defined status
func (c *acpconfigPolicypkgTsmV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetACPConfigByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Policypkg().SetACPConfigStatusByName(ctx, obj.ACPConfig, nil)
	return err
}

// GetStatus to get user defined status
func (c *acpconfigPolicypkgTsmV1Chainer) GetStatus(ctx context.Context) (result *basepolicypkgtsmtanzuvmwarecomv1.ACPStatus, err error) {
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetACPConfigByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *acpconfigPolicypkgTsmV1Chainer) SetStatus(ctx context.Context, status *basepolicypkgtsmtanzuvmwarecomv1.ACPStatus) (err error) {
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetACPConfigByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Policypkg().SetACPConfigStatusByName(ctx, obj.ACPConfig, status)
	return err
}

func (group *PolicypkgTsmV1) GetVMpolicyChildrenMap() map[string]basepolicypkgtsmtanzuvmwarecomv1.Child {
	return map[string]basepolicypkgtsmtanzuvmwarecomv1.Child{}
}

func (group *PolicypkgTsmV1) GetVMpolicyChild(grp, kind, name string) basepolicypkgtsmtanzuvmwarecomv1.Child {
	return basepolicypkgtsmtanzuvmwarecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetVMpolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) GetVMpolicyByName(ctx context.Context, hashedName string) (*PolicypkgVMpolicy, error) {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetVMpolicyByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetVMpolicyByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetVMpolicyByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &PolicypkgVMpolicy{
					client:   group.client,
					VMpolicy: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &PolicypkgVMpolicy{
				client:   group.client,
				VMpolicy: resWrCache.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			VMpolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &PolicypkgVMpolicy{
				client:   group.client,
				VMpolicy: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetVMpolicyByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get VMpolicies: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetVMpolicyByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetVMpolicyByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadVMpolicyByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) ForceReadVMpolicyByName(ctx context.Context, hashedName string) (*PolicypkgVMpolicy, error) {
	log.Debugf("[ForceReadVMpolicyByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			VMpolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadVMpolicyByName] Failed to Get VMpolicies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get VMpolicies: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadVMpolicyByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadVMpolicyByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadVMpolicyByName] Executed Successfully :%s", hashedName)
			return &PolicypkgVMpolicy{
				client:   group.client,
				VMpolicy: result,
			}, nil
		}
	}
}

// DeleteVMpolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) DeleteVMpolicyByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteVMpolicyByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			VMpolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteVMpolicyByName] Failed to get VMpolicies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get VMpolicies: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteVMpolicyByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteVMpolicyByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteVMpolicyByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			PolicypkgTsmV1().
			VMpolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteVMpolicyByName] failed to delete VMpolicies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete VMpolicies: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteVMpolicyByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteVMpolicyByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteVMpolicyByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("vmpolicies.policypkg.tsm.tanzu.vmware.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteVMpolicyByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentName, "vmpolicies.policypkg.tsm.tanzu.vmware.com", hashedName)

	return nil
}

// CreateVMpolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicypkgTsmV1) CreateVMpolicyByName(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy) (*PolicypkgVMpolicy, error) {
	log.Debugf("[CreateVMpolicyByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			VMpolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateVMpolicyByName] Failed to create VMpolicy: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create VMpolicy: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateVMpolicyByName] context canceled while creating VMpolicy: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateVMpolicyByName] VMpolicy: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.PolicypkgTsmV1().VMpolicies().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateVMpolicyByName] Unable to Get VMpolicy %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateVMpolicyByName] found unexpected error while creating VMpolicy: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateVMpolicyByName] VMpolicy: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("vmpolicies.policypkg.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[CreateVMpolicyByName] VMpolicy: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashedName, "vmpolicies.policypkg.tsm.tanzu.vmware.com", objToCreate.Name)

	log.Debugf("[CreateVMpolicyByName] Executed Successfully: %s", objToCreate.GetName())
	return &PolicypkgVMpolicy{
		client:   group.client,
		VMpolicy: result,
	}, nil
}

// UpdateVMpolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicypkgTsmV1) UpdateVMpolicyByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy) (*PolicypkgVMpolicy, error) {
	log.Debugf("[UpdateVMpolicyByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Policypkg().GetVMpolicyByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["vmpolicies.policypkg.tsm.tanzu.vmware.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			PolicypkgTsmV1().
			VMpolicies().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateVMpolicyByName] Failed to patch VMpolicy %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger VMpolicy Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteVMpolicyByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting VMpolicy: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("VMpolicy deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateVMpolicyByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateVMpolicyByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger VMpolicy Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteVMpolicyByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting VMpolicy: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("VMpolicy Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateVMpolicyByName] Patch VMpolicy Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("vmpolicies.policypkg.tsm.tanzu.vmware.com"); ok {
				log.Debugf("[UpdateVMpolicyByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateVMpolicyByName] Executed Successfully %s", objToUpdate.GetName())
	return &PolicypkgVMpolicy{
		client:   group.client,
		VMpolicy: result,
	}, nil
}

// ListVMpolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *PolicypkgTsmV1) ListVMpolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicypkgVMpolicy, err error) {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*PolicypkgVMpolicy, len(items))
		for k, v := range items {
			item, _ := v.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy)
			result[k] = &PolicypkgVMpolicy{
				client:   group.client,
				VMpolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.PolicypkgTsmV1().
			VMpolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*PolicypkgVMpolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &PolicypkgVMpolicy{
				client:   group.client,
				VMpolicy: &item,
			}
		}
	}
	return
}

type PolicypkgVMpolicy struct {
	client *Clientset
	*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy
}

// Delete removes obj and all it's children from the database.
func (obj *PolicypkgVMpolicy) Delete(ctx context.Context) error {
	err := obj.client.Policypkg().DeleteVMpolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.VMpolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicypkgVMpolicy) Update(ctx context.Context) error {
	result, err := obj.client.Policypkg().UpdateVMpolicyByName(ctx, obj.VMpolicy)
	if err != nil {
		return err
	}
	obj.VMpolicy = result.VMpolicy
	return nil
}

func (obj *PolicypkgVMpolicy) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type vmpolicyPolicypkgTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *vmpolicyPolicypkgTsmV1Chainer) Subscribe() {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewVMpolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *vmpolicyPolicypkgTsmV1Chainer) Unsubscribe() {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *vmpolicyPolicypkgTsmV1Chainer) IsSubscribed() bool {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *vmpolicyPolicypkgTsmV1Chainer) addCallback(obj *PolicypkgVMpolicy) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "vmpolicies.policypkg.tsm.tanzu.vmware.com", obj.Name)
}

func (c *vmpolicyPolicypkgTsmV1Chainer) deleteCallback(obj *PolicypkgVMpolicy) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.tsm.tanzu.vmware.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.tsm.tanzu.vmware.com", parentHashName, "vmpolicies.policypkg.tsm.tanzu.vmware.com", obj.Name)
}

func (c *vmpolicyPolicypkgTsmV1Chainer) RegisterEventHandler(addCB func(obj *PolicypkgVMpolicy), updateCB func(oldObj, newObj *PolicypkgVMpolicy), deleteCB func(obj *PolicypkgVMpolicy)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for PolicypkgVMpolicy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgVMpolicy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgVMpolicy, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewVMpolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &PolicypkgVMpolicy{
				client:   c.client,
				VMpolicy: obj.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &PolicypkgVMpolicy{
				client:   c.client,
				VMpolicy: oldObj.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}
			newData := &PolicypkgVMpolicy{
				client:   c.client,
				VMpolicy: newObj.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &PolicypkgVMpolicy{
				client:   c.client,
				VMpolicy: obj.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *vmpolicyPolicypkgTsmV1Chainer) RegisterAddCallback(cbfn func(obj *PolicypkgVMpolicy)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for PolicypkgVMpolicy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgVMpolicy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgVMpolicy, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewVMpolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &PolicypkgVMpolicy{
				client:   c.client,
				VMpolicy: obj.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				AddChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *vmpolicyPolicypkgTsmV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *PolicypkgVMpolicy)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for PolicypkgVMpolicy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgVMpolicy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgVMpolicy, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewVMpolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &PolicypkgVMpolicy{
				client:   c.client,
				VMpolicy: oldObj.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}
			newData := &PolicypkgVMpolicy{
				client:   c.client,
				VMpolicy: newObj.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *vmpolicyPolicypkgTsmV1Chainer) RegisterDeleteCallback(cbfn func(obj *PolicypkgVMpolicy)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for PolicypkgVMpolicy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for PolicypkgVMpolicy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for PolicypkgVMpolicy, so creating a new one")
		informer = informerpolicypkgtsmtanzuvmwarecomv1.NewVMpolicyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &PolicypkgVMpolicy{
				client:   c.client,
				VMpolicy: obj.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", nc.Labels, nc.Labels["configs.config.tsm.tanzu.vmware.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.tsm.tanzu.vmware.com", parent.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name) {
				RemoveChild("configs.config.tsm.tanzu.vmware.com", parent.Name, "vmpolicies.policypkg.tsm.tanzu.vmware.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}
